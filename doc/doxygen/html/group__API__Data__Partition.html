<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>StarPU Handbook: Data Partition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__API__Data__Partition.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Data Partition</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structstarpu__data__filter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a></td></tr>
<tr class="separator:structstarpu__data__filter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Basic API</h2></td></tr>
<tr class="memitem:ga1363109ba0e36c1b6c7f1a40c9608791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga1363109ba0e36c1b6c7f1a40c9608791">starpu_data_partition</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f)</td></tr>
<tr class="separator:ga1363109ba0e36c1b6c7f1a40c9608791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae80794b9cad7855a3ee54a4361f656ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gae80794b9cad7855a3ee54a4361f656ed">starpu_data_unpartition</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned gathering_node)</td></tr>
<tr class="separator:gae80794b9cad7855a3ee54a4361f656ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3f729055f14384e7397d2815a2c9a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga6a3f729055f14384e7397d2815a2c9a5">starpu_data_get_nb_children</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:ga6a3f729055f14384e7397d2815a2c9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e07c2c0604da63e7746a8018d8a62f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga29e07c2c0604da63e7746a8018d8a62f">starpu_data_get_child</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, unsigned i)</td></tr>
<tr class="separator:ga29e07c2c0604da63e7746a8018d8a62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24101bbe28b1d7d4a0874d349ba8979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned depth,...)</td></tr>
<tr class="separator:gac24101bbe28b1d7d4a0874d349ba8979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7904efb86ab3f9d6d682a3a3be3646fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7904efb86ab3f9d6d682a3a3be3646fe">starpu_data_vget_sub_data</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned depth, va_list pa)</td></tr>
<tr class="separator:ga7904efb86ab3f9d6d682a3a3be3646fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga551d6fa7fead5b9f7c8a85b1f9885e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga551d6fa7fead5b9f7c8a85b1f9885e91">starpu_data_map_filters</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned nfilters,...)</td></tr>
<tr class="separator:ga551d6fa7fead5b9f7c8a85b1f9885e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a28291a5045ef7ed3c93afc94ed248"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga15a28291a5045ef7ed3c93afc94ed248">starpu_data_vmap_filters</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> root_data, unsigned nfilters, va_list pa)</td></tr>
<tr class="separator:ga15a28291a5045ef7ed3c93afc94ed248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predefined Vector Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7fb4f57874a68dd59273529618faf2cd"></a>This section gives a partial list of the predefined partitioning functions for vector data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. The complete list can be found in the file <code><a class="el" href="starpu__data__filters_8h.html">starpu_data_filters.h</a></code>. </p>
</td></tr>
<tr class="memitem:ga212189d3b83dfa4e225609b5f2bf8461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga212189d3b83dfa4e225609b5f2bf8461">starpu_vector_filter_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga212189d3b83dfa4e225609b5f2bf8461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab49915dc0462c1b145bfb0a9ce4cf52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaab49915dc0462c1b145bfb0a9ce4cf52">starpu_vector_filter_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gaab49915dc0462c1b145bfb0a9ce4cf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fa487bfff5ccdd59210bdde65a11db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gab9fa487bfff5ccdd59210bdde65a11db">starpu_vector_filter_list</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gab9fa487bfff5ccdd59210bdde65a11db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab639622ea4929c36df704a0bebfd3fac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gab639622ea4929c36df704a0bebfd3fac">starpu_vector_filter_divide_in_2</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gab639622ea4929c36df704a0bebfd3fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predefined Matrix Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp40f9ddfd6d94d60c150ad542d9542fcf"></a>This section gives a partial list of the predefined partitioning functions for matrix data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. The complete list can be found in the file <code><a class="el" href="starpu__data__filters_8h.html">starpu_data_filters.h</a></code>. </p>
</td></tr>
<tr class="memitem:ga8c86b2af9e0806e631c1cbb5d506506b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga8c86b2af9e0806e631c1cbb5d506506b">starpu_matrix_filter_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga8c86b2af9e0806e631c1cbb5d506506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88fbca61843b76314e39a2c0f8b93d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga88fbca61843b76314e39a2c0f8b93d6c">starpu_matrix_filter_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga88fbca61843b76314e39a2c0f8b93d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2925be576ac7d597ecead381ff32a894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga2925be576ac7d597ecead381ff32a894">starpu_matrix_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga2925be576ac7d597ecead381ff32a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7132923bd901e0e4254cc0b20d49997a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7132923bd901e0e4254cc0b20d49997a">starpu_matrix_filter_vertical_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga7132923bd901e0e4254cc0b20d49997a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predefined Block Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp37648ac3f0915927087c62fb10379c9c"></a>This section gives a partial list of the predefined partitioning functions for block data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. The complete list can be found in the file <code><a class="el" href="starpu__data__filters_8h.html">starpu_data_filters.h</a></code>. A usage example is available in examples/filters/shadow3d.c </p>
</td></tr>
<tr class="memitem:ga1a265ffca51fae58701832a4daa53bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga1a265ffca51fae58701832a4daa53bd9">starpu_block_filter_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga1a265ffca51fae58701832a4daa53bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc8832e25f2f4049ba5a0053b122dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7cc8832e25f2f4049ba5a0053b122dd9">starpu_block_filter_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga7cc8832e25f2f4049ba5a0053b122dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73a2c9af1200c68f0403e70e36c020d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga73a2c9af1200c68f0403e70e36c020d0">starpu_block_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga73a2c9af1200c68f0403e70e36c020d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa4818b571e98acd8696a1251b0d4e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gafa4818b571e98acd8696a1251b0d4e74">starpu_block_filter_vertical_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gafa4818b571e98acd8696a1251b0d4e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4f93ab3326ded72c3a80d337e6f4a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaae4f93ab3326ded72c3a80d337e6f4a1">starpu_block_filter_depth_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gaae4f93ab3326ded72c3a80d337e6f4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b9ec529f67e5c300e7eed3e185fbaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac4b9ec529f67e5c300e7eed3e185fbaf">starpu_block_filter_depth_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gac4b9ec529f67e5c300e7eed3e185fbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predefined BCSR Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd93eeddd2d8e1976c5a8afc351886d12"></a>This section gives a partial list of the predefined partitioning functions for BCSR data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. The complete list can be found in the file <code><a class="el" href="starpu__data__filters_8h.html">starpu_data_filters.h</a></code>. </p>
</td></tr>
<tr class="memitem:ga0e1bee4821237529d554605d333e9109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga0e1bee4821237529d554605d333e9109">starpu_bcsr_filter_canonical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga0e1bee4821237529d554605d333e9109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554a2fb14fdee9353364c39f36ee3a6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga554a2fb14fdee9353364c39f36ee3a6f">starpu_csr_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga554a2fb14fdee9353364c39f36ee3a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structstarpu__data__filter" id="structstarpu__data__filter"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct starpu_data_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The filter structure describes a data partitioning operation, to be given to the <a class="el" href="group__API__Data__Partition.html#ga1363109ba0e36c1b6c7f1a40c9608791">starpu_data_partition()</a> function. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a1fe0cc960cc4a6a2db7c2e8295b121ca"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#a1fe0cc960cc4a6a2db7c2e8295b121ca">filter_func</a> )(void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:a1fe0cc960cc4a6a2db7c2e8295b121ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec46586c98b5631201151b7582724e12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#aec46586c98b5631201151b7582724e12">nchildren</a></td></tr>
<tr class="separator:aec46586c98b5631201151b7582724e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1a8e13ad0f9c970a30232d583b07b4"><td class="memItemLeft" align="right" valign="top">unsigned(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#aba1a8e13ad0f9c970a30232d583b07b4">get_nchildren</a> )(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle)</td></tr>
<tr class="separator:aba1a8e13ad0f9c970a30232d583b07b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930eea80978a13822793f04e93e8a445"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#a930eea80978a13822793f04e93e8a445">get_child_ops</a> )(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id)</td></tr>
<tr class="separator:a930eea80978a13822793f04e93e8a445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb631e64e61f862647040852fdabe49"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#a6cb631e64e61f862647040852fdabe49">filter_arg</a></td></tr>
<tr class="separator:a6cb631e64e61f862647040852fdabe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadc5f4c1657e545f2139332321c6450"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#aeadc5f4c1657e545f2139332321c6450">filter_arg_ptr</a></td></tr>
<tr class="separator:aeadc5f4c1657e545f2139332321c6450"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a1fe0cc960cc4a6a2db7c2e8295b121ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_data_filter::filter_func)(void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id, unsigned nparts)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function fills the child_interface structure with interface information for the id-th child of the parent father_interface (among nparts). </p>

</div>
</div>
<a class="anchor" id="aec46586c98b5631201151b7582724e12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned starpu_data_filter::nchildren</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the number of parts to partition the data into. </p>

</div>
</div>
<a class="anchor" id="aba1a8e13ad0f9c970a30232d583b07b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned(* starpu_data_filter::get_nchildren)(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> initial_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the number of children. This can be used instead of nchildren when the number of children depends on the actual data (e.g. the number of blocks in a sparse matrix). </p>

</div>
</div>
<a class="anchor" id="a930eea80978a13822793f04e93e8a445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> *(* starpu_data_filter::get_child_ops)(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In case the resulting children use a different data interface, this function returns which interface is used by child number id. </p>

</div>
</div>
<a class="anchor" id="a6cb631e64e61f862647040852fdabe49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned starpu_data_filter::filter_arg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow to define an additional parameter for the filter function. </p>

</div>
</div>
<a class="anchor" id="aeadc5f4c1657e545f2139332321c6450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * starpu_data_filter::filter_arg_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow to define an additional pointer parameter for the filter function, such as the sizes of the different parts. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1363109ba0e36c1b6c7f1a40c9608791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This requests partitioning one StarPU data initial_handle into several subdata according to the filter <code>f</code>.</p>
<p>Here an example of how to use the function. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> f = {</div>
<div class="line">        .<a class="code" href="group__API__Data__Partition.html#a1fe0cc960cc4a6a2db7c2e8295b121ca">filter_func</a> = <a class="code" href="group__API__Data__Partition.html#ga8c86b2af9e0806e631c1cbb5d506506b">starpu_matrix_filter_block</a>,</div>
<div class="line">        .nchildren = nslicesx,</div>
<div class="line">        .get_nchildren = NULL,</div>
<div class="line">        .get_child_ops = NULL</div>
<div class="line">};</div>
<div class="line"><a class="code" href="group__API__Data__Partition.html#ga1363109ba0e36c1b6c7f1a40c9608791">starpu_data_partition</a>(A_handle, &amp;f);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae80794b9cad7855a3ee54a4361f656ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unpartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>gathering_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This unapplies one filter, thus unpartitioning the data. The pieces of data are collected back into one big piece in the <code>gathering_node</code> (usually STARPU_MAIN_RAM). Tasks working on the partitioned data must be already finished when calling <a class="el" href="group__API__Data__Partition.html#gae80794b9cad7855a3ee54a4361f656ed">starpu_data_unpartition()</a>.</p>
<p>Here an example of how to use the function. </p><div class="fragment"><div class="line"><a class="code" href="group__API__Data__Partition.html#gae80794b9cad7855a3ee54a4361f656ed">starpu_data_unpartition</a>(A_handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6a3f729055f14384e7397d2815a2c9a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_get_nb_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the number of children. </p>

</div>
</div>
<a class="anchor" id="ga29e07c2c0604da63e7746a8018d8a62f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> starpu_data_get_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ith child of the given <code>handle</code>, which must have been partitionned beforehand. </p>

</div>
</div>
<a class="anchor" id="gac24101bbe28b1d7d4a0874d349ba8979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> starpu_data_get_sub_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After partitioning a StarPU data by applying a filter, <a class="el" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data()</a> can be used to get handles for each of the data portions. <code>root_data</code> is the parent data that was partitioned. <code>depth</code> is the number of filters to traverse (in case several filters have been applied, to e.g. partition in row blocks, and then in column blocks), and the subsequent parameters are the indexes. The function returns a handle to the subdata.</p>
<p>Here an example of how to use the function. </p><div class="fragment"><div class="line">h = <a class="code" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data</a>(A_handle, 1, taskx);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7904efb86ab3f9d6d682a3a3be3646fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> starpu_data_vget_sub_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to <a class="el" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data()</a> but uses a va_list for the parameter list. </p>

</div>
</div>
<a class="anchor" id="ga551d6fa7fead5b9f7c8a85b1f9885e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_map_filters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nfilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies <code>nfilters</code> filters to the handle designated by <code>root_handle</code> recursively. <code>nfilters</code> pointers to variables of the type <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> should be given. </p>

</div>
</div>
<a class="anchor" id="ga15a28291a5045ef7ed3c93afc94ed248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_vmap_filters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nfilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies <code>nfilters</code> filters to the handle designated by <code>root_handle</code> recursively. It uses a va_list of pointers to variables of the type <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a>. </p>

</div>
</div>
<a class="anchor" id="ga212189d3b83dfa4e225609b5f2bf8461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned in <code>nparts</code> chunks of equal size. </p>

</div>
</div>
<a class="anchor" id="gaab49915dc0462c1b145bfb0a9ce4cf52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned in <code>nparts</code> chunks of equal size with a shadow border <code>filter_arg_ptr</code>, thus getting a vector of size (n-2*shadow)/nparts+2*shadow. The <code>filter_arg_ptr</code> field of <code>f</code> must be the shadow size casted into void*. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. An usage example is available in examples/filters/shadow.c </p>

</div>
</div>
<a class="anchor" id="gab9fa487bfff5ccdd59210bdde65a11db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_list </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned into <code>nparts</code> chunks according to the <code>filter_arg_ptr</code> field of <code>f</code>. The <code>filter_arg_ptr</code> field must point to an array of <code>nparts</code> uint32_t elements, each of which specifies the number of elements in each chunk of the partition. </p>

</div>
</div>
<a class="anchor" id="gab639622ea4929c36df704a0bebfd3fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_divide_in_2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned in <code>2</code> chunks of equal size, ignoring nparts. Thus, <code>id</code> must be <code>0</code> or <code>1</code>. </p>

</div>
</div>
<a class="anchor" id="ga8c86b2af9e0806e631c1cbb5d506506b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a dense Matrix along the x dimension, thus getting (x/<code>nparts</code> ,y) matrices. If <code>nparts</code> does not divide x, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="ga88fbca61843b76314e39a2c0f8b93d6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a dense Matrix along the x dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting ((x-2*shadow)/<code>nparts</code> +2*shadow,y) matrices. If <code>nparts</code> does not divide x-2*shadow, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. A usage example is available in examples/filters/shadow2d.c </p>

</div>
</div>
<a class="anchor" id="ga2925be576ac7d597ecead381ff32a894"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a dense Matrix along the y dimension, thus getting (x,y/<code>nparts</code>) matrices. If <code>nparts</code> does not divide y, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="ga7132923bd901e0e4254cc0b20d49997a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_vertical_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a dense Matrix along the y dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting (x,(y-2*shadow)/<code>nparts</code> +2*shadow) matrices. If <code>nparts</code> does not divide y-2*shadow, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. A usage example is available in examples/filters/shadow2d.c </p>

</div>
</div>
<a class="anchor" id="ga1a265ffca51fae58701832a4daa53bd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the X dimension, thus getting (x/<code>nparts</code> ,y,z) 3D matrices. If <code>nparts</code> does not divide x, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="ga7cc8832e25f2f4049ba5a0053b122dd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the X dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting ((x-2*shadow)/<code>nparts</code> +2*shadow,y,z) blocks. If <code>nparts</code> does not divide x, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. </p>

</div>
</div>
<a class="anchor" id="ga73a2c9af1200c68f0403e70e36c020d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the Y dimension, thus getting (x,y/<code>nparts</code> ,z) blocks. If <code>nparts</code> does not divide y, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="gafa4818b571e98acd8696a1251b0d4e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_vertical_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the Y dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting (x,(y-2*shadow)/<code>nparts</code> +2*shadow,z) 3D matrices. If <code>nparts</code> does not divide y, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. </p>

</div>
</div>
<a class="anchor" id="gaae4f93ab3326ded72c3a80d337e6f4a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_depth_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the Z dimension, thus getting (x,y,z/<code>nparts</code>) blocks. If <code>nparts</code> does not divide z, the last submatrix contains the remainder. </p>

</div>
</div>
<a class="anchor" id="gac4b9ec529f67e5c300e7eed3e185fbaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_depth_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block along the Z dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting (x,y,(z-2*shadow)/<code>nparts</code> +2*shadow) blocks. If <code>nparts</code> does not divide z, the last submatrix contains the remainder. <b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. </p>

</div>
</div>
<a class="anchor" id="ga0e1bee4821237529d554605d333e9109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_bcsr_filter_canonical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block-sparse matrix into dense matrices. </p>

</div>
</div>
<a class="anchor" id="ga554a2fb14fdee9353364c39f36ee3a6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_csr_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This partitions a block-sparse matrix into vertical block-sparse matrices. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 6 2015 21:13:12 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
