<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>StarPU Handbook: Basic Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('BasicExamples.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Basic Examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="HelloWorldUsingTheCExtension"></a>
Hello World Using The C Extension</h1>
<p>This section shows how to implement a simple program that submits a task to StarPU using the StarPU C extension (<a class="el" href="cExtensions.html">C Extensions</a>). The complete example, and additional examples, is available in the directory <code>gcc-plugin/examples</code> of the StarPU distribution. A similar example showing how to directly use the StarPU's API is shown in <a class="el" href="BasicExamples.html#HelloWorldUsingStarPUAPI">Hello World Using StarPU's API</a>.</p>
<p>GCC from version 4.5 permit to use the StarPU GCC plug-in (<a class="el" href="cExtensions.html">C Extensions</a>). This makes writing a task both simpler and less error-prone. In a nutshell, all it takes is to declare a task, declare and define its implementations (for CPU, OpenCL, and/or CUDA), and invoke the task like a regular C function. The example below defines <code>my_task</code> which has a single implementation for CPU:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* Task declaration.  */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> my_task (<span class="keywordtype">int</span> x) __attribute__ ((task));</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Definition of the CPU implementation of `my_task&#39;.  */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> my_task (<span class="keywordtype">int</span> x)</div>
<div class="line">{</div>
<div class="line">  printf (<span class="stringliteral">&quot;Hello, world!  With x = %d\n&quot;</span>, x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">/* Initialize StarPU. */</span></div>
<div class="line"><span class="preprocessor">#pragma starpu initialize</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Do an asynchronous call to `my_task&#39;. */</span></div>
<div class="line">  my_task (42);</div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Wait for the call to complete.  */</span></div>
<div class="line"><span class="preprocessor">#pragma starpu wait</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Terminate. */</span></div>
<div class="line"><span class="preprocessor">#pragma starpu shutdown</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The code can then be compiled and linked with GCC and the flag <code>-fplugin</code>:</p>
<pre class="fragment">$ gcc `pkg-config starpu-1.2 --cflags` hello-starpu.c \
    -fplugin=`pkg-config starpu-1.2 --variable=gccplugin` \
    `pkg-config starpu-1.2 --libs`
</pre><p>The code can also be compiled without the StarPU C extension and will behave as a normal sequential code.</p>
<pre class="fragment">$ gcc hello-starpu.c
hello-starpu.c:33:1: warning: ‘task’ attribute directive ignored [-Wattributes]
$ ./a.out
Hello, world! With x = 42
</pre><p>As can be seen above, the C extensions allows programmers to use StarPU tasks by essentially annotating ``regular'' C code.</p>
<h1><a class="anchor" id="HelloWorldUsingStarPUAPI"></a>
Hello World Using StarPU's API</h1>
<p>This section shows how to achieve the same result as in the previous section using StarPU's standard C API.</p>
<h2><a class="anchor" id="RequiredHeaders"></a>
Required Headers</h2>
<p>The header <a class="el" href="starpu_8h.html">starpu.h</a> should be included in any code using StarPU.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="starpu_8h.html">starpu.h</a>&gt;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="DefiningACodelet"></a>
Defining A Codelet</h2>
<p>A codelet is a structure that represents a computational kernel. Such a codelet may contain an implementation of the same kernel on different architectures (e.g. CUDA, x86, ...). For compatibility, make sure that the whole structure is properly initialized to zero, either by using the function <a class="el" href="group__API__Codelet__And__Tasks.html#ga46b34c28e0b9b2e1726b9d033639dda7">starpu_codelet_init()</a>, or by letting the compiler implicitly do it as examplified above.</p>
<p>The field <a class="el" href="group__API__Codelet__And__Tasks.html#a1bb02f890f2e10c348499dbd92b56496">starpu_codelet::nbuffers</a> specifies the number of data buffers that are manipulated by the codelet: here the codelet does not access or modify any data that is controlled by our data management library.</p>
<p>We create a codelet which may only be executed on the CPUs. When a CPU core will execute a codelet, it will call the function <code>cpu_func</code>, which <em>must</em> have the following prototype:</p>
<div class="fragment"><div class="line">void (*cpu_func)(<span class="keywordtype">void</span> *buffers[], <span class="keywordtype">void</span> *cl_arg);</div>
</div><!-- fragment --><p>In this example, we can ignore the first argument of this function which gives a description of the input and output buffers (e.g. the size and the location of the matrices) since there is none. We also ignore the second argument which is a pointer to optional arguments for the codelet.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> cpu_func(<span class="keywordtype">void</span> *buffers[], <span class="keywordtype">void</span> *cl_arg)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;Hello world\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> cl =</div>
<div class="line">{</div>
<div class="line">    .<a class="code" href="group__API__Codelet__And__Tasks.html#a593418a8961318e4085177abeeaa43ad">cpu_funcs</a> = { <a class="code" href="group__API__Codelet__And__Tasks.html#ad5f00ed5a0a59b72c0d90d9718376893">cpu_func</a> },</div>
<div class="line">    .nbuffers = 0</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="SubmittingATask"></a>
Submitting A Task</h2>
<p>Before submitting any tasks to StarPU, <a class="el" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init()</a> must be called. The <code>NULL</code> argument specifies that we use the default configuration. Tasks cannot be submitted after the termination of StarPU by a call to <a class="el" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown()</a>.</p>
<p>In the example above, a task structure is allocated by a call to <a class="el" href="group__API__Codelet__And__Tasks.html#ga8720143096f8274be1b6ae75a1abd0ed">starpu_task_create()</a>. This function only allocates and fills the corresponding structure with the default settings, but it does not submit the task to StarPU.</p>
<p>The field <a class="el" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">starpu_task::cl</a> is a pointer to the codelet which the task will execute: in other words, the codelet structure describes which computational kernel should be offloaded on the different architectures, and the task structure is a wrapper containing a codelet and the piece of data on which the codelet should operate.</p>
<p>If the field <a class="el" href="group__API__Codelet__And__Tasks.html#a18439d7a6d4ad65b75c75ec02d60075e">starpu_task::synchronous</a> is non-zero, task submission will be synchronous: the function <a class="el" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit()</a> will not return until the task has been executed. Note that the function <a class="el" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown()</a> does not guarantee that asynchronous tasks have been executed before it returns, <a class="el" href="group__API__Codelet__And__Tasks.html#gad0baa8dbfd13e5a7bc3651bcd76022aa">starpu_task_wait_for_all()</a> can be used to that effect, or data can be unregistered (<a class="el" href="group__API__Data__Management.html#ga586146498466b60d6b81145dfaeb8948">starpu_data_unregister()</a>), which will implicitly wait for all the tasks scheduled to work on it, unless explicitly disabled thanks to <a class="el" href="group__API__Implicit__Data__Dependencies.html#ga26f17239b14354e61eef0710ffadc434">starpu_data_set_default_sequential_consistency_flag()</a> or <a class="el" href="group__API__Implicit__Data__Dependencies.html#ga273df19e4cad1c05ec5df697bcec4444">starpu_data_set_sequential_consistency_flag()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* initialize StarPU */</span></div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init</a>(NULL);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> *task = <a class="code" href="group__API__Codelet__And__Tasks.html#ga8720143096f8274be1b6ae75a1abd0ed">starpu_task_create</a>();</div>
<div class="line"></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a> = &amp;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a>; <span class="comment">/* Pointer to the codelet defined above */</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">/* starpu_task_submit will be a blocking call. If unset,</span></div>
<div class="line"><span class="comment">    starpu_task_wait() needs to be called after submitting the task. */</span></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#a18439d7a6d4ad65b75c75ec02d60075e">synchronous</a> = 1;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* submit the task to StarPU */</span></div>
<div class="line">    <a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* terminate StarPU */</span></div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="ExecutionOfHelloWorld"></a>
Execution Of Hello World</h2>
<pre class="fragment">$ make hello_world
cc $(pkg-config --cflags starpu-1.2) hello_world.c -o hello_world $(pkg-config --libs starpu-1.2)
$ ./hello_world
Hello world
</pre><h2><a class="anchor" id="PassingArgumentsToTheCodelet"></a>
Passing Arguments To The Codelet</h2>
<p>The optional field <a class="el" href="group__API__Codelet__And__Tasks.html#a08dfa6e007d0ada924ac388679ec2b91">starpu_task::cl_arg</a> field is a pointer to a buffer (of size <a class="el" href="group__API__Codelet__And__Tasks.html#adac9af88fed23241fc65259712352126">starpu_task::cl_arg_size</a>) with some parameters for the kernel described by the codelet. For instance, if a codelet implements a computational kernel that multiplies its input vector by a constant, the constant could be specified by the means of this buffer, instead of registering it as a StarPU data. It must however be noted that StarPU avoids making copy whenever possible and rather passes the pointer as such, so the buffer which is pointed at must be kept allocated until the task terminates, and if several tasks are submitted with various parameters, each of them must be given a pointer to their own buffer.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>params</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordtype">float</span> f;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> cpu_func(<span class="keywordtype">void</span> *buffers[], <span class="keywordtype">void</span> *cl_arg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>params *params = cl_arg;</div>
<div class="line"></div>
<div class="line">    printf(<span class="stringliteral">&quot;Hello world (params = {%i, %f} )\n&quot;</span>, params-&gt;i, params-&gt;f);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As said before, the field <a class="el" href="group__API__Codelet__And__Tasks.html#a1bb02f890f2e10c348499dbd92b56496">starpu_codelet::nbuffers</a> specifies the number of data buffers that are manipulated by the codelet. It does not count the argument &mdash; the parameter <code>cl_arg</code> of the function <code>cpu_func</code> &mdash; since it is not managed by our data management library, but just contains trivial parameters.</p>
<p>Be aware that this may be a pointer to a <em>copy</em> of the actual buffer, and not the pointer given by the programmer: if the codelet modifies this buffer, there is no guarantee that the initial buffer will be modified as well: this for instance implies that the buffer cannot be used as a synchronization medium. If synchronization is needed, data has to be registered to StarPU, see <a class="el" href="BasicExamples.html#VectorScalingUsingStarPUAPI">Vector Scaling Using StarPU's API</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* initialize StarPU */</span></div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init</a>(NULL);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> *task = <a class="code" href="group__API__Codelet__And__Tasks.html#ga8720143096f8274be1b6ae75a1abd0ed">starpu_task_create</a>();</div>
<div class="line"></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a> = &amp;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a>; <span class="comment">/* Pointer to the codelet defined above */</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span>params params = { 1, 2.0f };</div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#a08dfa6e007d0ada924ac388679ec2b91">cl_arg</a> = &amp;params;</div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#adac9af88fed23241fc65259712352126">cl_arg_size</a> = <span class="keyword">sizeof</span>(params);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* starpu_task_submit will be a blocking call */</span></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#a18439d7a6d4ad65b75c75ec02d60075e">synchronous</a> = 1;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* submit the task to StarPU */</span></div>
<div class="line">    <a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* terminate StarPU */</span></div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><pre class="fragment">$ make hello_world
cc $(pkg-config --cflags starpu-1.2) hello_world.c -o hello_world $(pkg-config --libs starpu-1.2)
$ ./hello_world
Hello world (params = {1, 2.000000} )
</pre><h2><a class="anchor" id="DefiningACallback"></a>
Defining A Callback</h2>
<p>Once a task has been executed, an optional callback function <a class="el" href="group__API__Codelet__And__Tasks.html#aece9779d31a532e836b2cf5e654d7fb6">starpu_task::callback_func</a> is called when defined. While the computational kernel could be offloaded on various architectures, the callback function is always executed on a CPU. The pointer <a class="el" href="group__API__Codelet__And__Tasks.html#aaa114d89c298bbd66c6d8b1c06130297">starpu_task::callback_arg</a> is passed as an argument of the callback function. The prototype of a callback function must be:</p>
<div class="fragment"><div class="line">void (*callback_function)(<span class="keywordtype">void</span> *);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> callback_func(<span class="keywordtype">void</span> *callback_arg)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;Callback function (arg %x)\n&quot;</span>, callback_arg);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* initialize StarPU */</span></div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init</a>(NULL);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> *task = <a class="code" href="group__API__Codelet__And__Tasks.html#ga8720143096f8274be1b6ae75a1abd0ed">starpu_task_create</a>();</div>
<div class="line"></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a> = &amp;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a>; <span class="comment">/* Pointer to the codelet defined above */</span></div>
<div class="line"></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#aece9779d31a532e836b2cf5e654d7fb6">callback_func</a> = <a class="code" href="group__API__Codelet__And__Tasks.html#aece9779d31a532e836b2cf5e654d7fb6">callback_func</a>;</div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#aaa114d89c298bbd66c6d8b1c06130297">callback_arg</a> = 0x42;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* starpu_task_submit will be a blocking call */</span></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#a18439d7a6d4ad65b75c75ec02d60075e">synchronous</a> = 1;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* submit the task to StarPU */</span></div>
<div class="line">    <a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* terminate StarPU */</span></div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><pre class="fragment">$ make hello_world
cc $(pkg-config --cflags starpu-1.2) hello_world.c -o hello_world $(pkg-config --libs starpu-1.2) 
$ ./hello_world
Hello world
Callback function (arg 42)
</pre><h2><a class="anchor" id="WhereToExecuteACodelet"></a>
Where To Execute A Codelet</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> cl =</div>
<div class="line">{</div>
<div class="line">    .<a class="code" href="group__API__Codelet__And__Tasks.html#a504b8e20f53f469358eadb1ed800f72c">where</a> = <a class="code" href="group__API__Codelet__And__Tasks.html#gaf577e4415a639beffbc48b65454b88ca">STARPU_CPU</a>,</div>
<div class="line">    .cpu_funcs = { <a class="code" href="group__API__Codelet__And__Tasks.html#ad5f00ed5a0a59b72c0d90d9718376893">cpu_func</a> },</div>
<div class="line">    .cpu_funcs_name = { <span class="stringliteral">&quot;cpu_func&quot;</span> },</div>
<div class="line">     .nbuffers = 0</div>
<div class="line">};</div>
</div><!-- fragment --><p>We create a codelet which may only be executed on the CPUs. The optional field <a class="el" href="group__API__Codelet__And__Tasks.html#a504b8e20f53f469358eadb1ed800f72c">starpu_codelet::where</a> is a bitmask that defines where the codelet may be executed. Here, the value <a class="el" href="group__API__Codelet__And__Tasks.html#gaf577e4415a639beffbc48b65454b88ca">STARPU_CPU</a> means that only CPUs can execute this codelet. When the optional field <a class="el" href="group__API__Codelet__And__Tasks.html#a504b8e20f53f469358eadb1ed800f72c">starpu_codelet::where</a> is unset, its value is automatically set based on the availability of the different fields <code>XXX_funcs</code>.</p>
<p>TODO: explain <a class="el" href="group__API__Codelet__And__Tasks.html#a323b97f3a8b106d6f6d4cbc79b52de92">starpu_codelet::cpu_funcs_name</a></p>
<h1><a class="anchor" id="VectorScalingUsingTheCExtension"></a>
Vector Scaling Using the C Extension</h1>
<p>The previous example has shown how to submit tasks. In this section, we show how StarPU tasks can manipulate data.</p>
<p>We will first show how to use the C language extensions provided by the GCC plug-in (<a class="el" href="cExtensions.html">C Extensions</a>). The complete example, and additional examples, is available in the directory <code>gcc-plugin/examples</code> of the StarPU distribution. These extensions map directly to StarPU's main concepts: tasks, task implementations for CPU, OpenCL, or CUDA, and registered data buffers. The standard C version that uses StarPU's standard C programming interface is given in <a class="el" href="BasicExamples.html#VectorScalingUsingStarPUAPI">Vector Scaling Using StarPU's API</a>.</p>
<p>First of all, the vector-scaling task and its simple CPU implementation has to be defined:</p>
<div class="fragment"><div class="line"><span class="comment">/* Declare the `vector_scal&#39; task.  */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> vector_scal (<span class="keywordtype">unsigned</span> size, <span class="keywordtype">float</span> vector[size],</div>
<div class="line">                         <span class="keywordtype">float</span> factor)</div>
<div class="line">  __attribute__ ((task));</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Define the standard CPU implementation.  */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">vector_scal (<span class="keywordtype">unsigned</span> size, <span class="keywordtype">float</span> vector[size], <span class="keywordtype">float</span> factor)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">unsigned</span> i;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; size; i++)</div>
<div class="line">    vector[i] *= factor;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, the body of the program, which uses the task defined above, can be implemented:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#pragma starpu initialize</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define NX     0x100000</span></div>
<div class="line"><span class="preprocessor">#define FACTOR 3.14</span></div>
<div class="line"></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">float</span> vector[NX]</div>
<div class="line">       __attribute__ ((heap_allocated, registered));</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> i;</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; NX; i++)</div>
<div class="line">      vector[i] = (<span class="keywordtype">float</span>) i;</div>
<div class="line"></div>
<div class="line">    vector_scal (NX, vector, FACTOR);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#pragma starpu wait</span></div>
<div class="line">  } <span class="comment">/* VECTOR is automatically freed here. */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#pragma starpu shutdown</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> valid ? EXIT_SUCCESS : EXIT_FAILURE;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The function <code>main</code> above does several things:</p>
<ul>
<li>
It initializes StarPU.  </li>
<li>
It allocates <code>vector</code> in the heap; it will automatically be freed when its scope is left. Alternatively, good old <code>malloc</code> and <code>free</code> could have been used, but they are more error-prone and require more typing.  </li>
<li>
It registers the memory pointed to by <code>vector</code>. Eventually, when OpenCL or CUDA task implementations are added, this will allow StarPU to transfer that memory region between GPUs and the main memory. Removing this <code>pragma</code> is an error.  </li>
<li>
It invokes the task <code>vector_scal</code>. The invocation looks the same as a standard C function call. However, it is an asynchronous invocation, meaning that the actual call is performed in parallel with the caller's continuation.  </li>
<li>
It waits for the termination of the asynchronous call <code>vector_scal</code>.  </li>
<li>
Finally, StarPU is shut down.  </li>
</ul>
<p>The program can be compiled and linked with GCC and the flag <code>-fplugin</code>:</p>
<pre class="fragment">$ gcc `pkg-config starpu-1.2 --cflags` vector_scal.c \
    -fplugin=`pkg-config starpu-1.2 --variable=gccplugin` \
    `pkg-config starpu-1.2 --libs`
</pre><p>And voilà!</p>
<h2><a class="anchor" id="AddingAnOpenCLTaskImplementation"></a>
Adding an OpenCL Task Implementation</h2>
<p>Now, this is all fine and great, but you certainly want to take advantage of these newfangled GPUs that your lab just bought, don't you?</p>
<p>So, let's add an OpenCL implementation of the task <code>vector_scal</code>. We assume that the OpenCL kernel is available in a file, <code>vector_scal_opencl_kernel.cl</code>, not shown here. The OpenCL task implementation is similar to that used with the standard C API (<a class="el" href="BasicExamples.html#DefinitionOfTheOpenCLKernel">Definition of the OpenCL Kernel</a>). It is declared and defined in our C file like this:</p>
<div class="fragment"><div class="line"><span class="comment">/* The OpenCL programs, loaded from &#39;main&#39; (see below). */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="group__API__OpenCL__Extensions.html#structstarpu__opencl__program">starpu_opencl_program</a> cl_programs;</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> vector_scal_opencl (<span class="keywordtype">unsigned</span> size, <span class="keywordtype">float</span> vector[size],</div>
<div class="line">                                <span class="keywordtype">float</span> factor)</div>
<div class="line">  __attribute__ ((task_implementation (<span class="stringliteral">&quot;opencl&quot;</span>, vector_scal)));</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">vector_scal_opencl (<span class="keywordtype">unsigned</span> size, <span class="keywordtype">float</span> vector[size], <span class="keywordtype">float</span> factor)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> id, devid, err;</div>
<div class="line">  cl_kernel kernel;</div>
<div class="line">  cl_command_queue queue;</div>
<div class="line">  cl_event event;</div>
<div class="line"></div>
<div class="line">  <span class="comment">/* VECTOR is GPU memory pointer, not a main memory pointer. */</span></div>
<div class="line">  cl_mem val = (cl_mem) vector;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">id</span> = <a class="code" href="group__API__Workers__Properties.html#gac6d06f4e22b63bf50bc8e836cf16f81f">starpu_worker_get_id</a> ();</div>
<div class="line">  devid = <a class="code" href="group__API__Workers__Properties.html#ga0c9b9b7f5195cb8cbc5ee1223ec0f264">starpu_worker_get_devid</a> (<span class="keywordtype">id</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Prepare to invoke the kernel.  In the future, this will be largely automated.  */</span></div>
<div class="line">  err = <a class="code" href="group__API__OpenCL__Extensions.html#ga1d06b6c00b15f4fcd8d4c0c998f955ac">starpu_opencl_load_kernel</a> (&amp;kernel, &amp;queue, &amp;cl_programs,</div>
<div class="line">                                   <span class="stringliteral">&quot;vector_mult_opencl&quot;</span>, devid);</div>
<div class="line">  <span class="keywordflow">if</span> (err != CL_SUCCESS)</div>
<div class="line">    <a class="code" href="group__API__OpenCL__Extensions.html#ga6680ed21ce09f073fa0256169f4e4868">STARPU_OPENCL_REPORT_ERROR</a> (err);</div>
<div class="line"></div>
<div class="line">  err = clSetKernelArg (kernel, 0, <span class="keyword">sizeof</span> (size), &amp;size);</div>
<div class="line">  err |= clSetKernelArg (kernel, 1, <span class="keyword">sizeof</span> (val), &amp;val);</div>
<div class="line">  err |= clSetKernelArg (kernel, 2, <span class="keyword">sizeof</span> (factor), &amp;factor);</div>
<div class="line">  <span class="keywordflow">if</span> (err)</div>
<div class="line">    <a class="code" href="group__API__OpenCL__Extensions.html#ga6680ed21ce09f073fa0256169f4e4868">STARPU_OPENCL_REPORT_ERROR</a> (err);</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">size_t</span> global = 1, local = 1;</div>
<div class="line">  err = clEnqueueNDRangeKernel (queue, kernel, 1, NULL, &amp;global,</div>
<div class="line">                                &amp;local, 0, NULL, &amp;event);</div>
<div class="line">  <span class="keywordflow">if</span> (err != CL_SUCCESS)</div>
<div class="line">    <a class="code" href="group__API__OpenCL__Extensions.html#ga6680ed21ce09f073fa0256169f4e4868">STARPU_OPENCL_REPORT_ERROR</a> (err);</div>
<div class="line"></div>
<div class="line">  clFinish (queue);</div>
<div class="line">  <a class="code" href="group__API__OpenCL__Extensions.html#gaeaabc8e5d90531a21a8307c06c659984">starpu_opencl_collect_stats</a> (event);</div>
<div class="line">  clReleaseEvent (event);</div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Done with KERNEL. */</span></div>
<div class="line">  <a class="code" href="group__API__OpenCL__Extensions.html#ga68adf424491ec715e891000fa4a6030d">starpu_opencl_release_kernel</a> (kernel);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The OpenCL kernel itself must be loaded from <code>main</code>, sometime after the pragma <code>initialize</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__OpenCL__Extensions.html#ga3441dd1c6e61717dd81a3a6eb0bf75a8">starpu_opencl_load_opencl_from_file</a> (<span class="stringliteral">&quot;vector_scal_opencl_kernel.cl&quot;</span>,</div>
<div class="line">                                       &amp;cl_programs, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>And that's it. The task <code>vector_scal</code> now has an additional implementation, for OpenCL, which StarPU's scheduler may choose to use at run-time. Unfortunately, the <code>vector_scal_opencl</code> above still has to go through the common OpenCL boilerplate; in the future, additional extensions will automate most of it.</p>
<h2><a class="anchor" id="AddingACUDATaskImplementation"></a>
Adding a CUDA Task Implementation</h2>
<p>Adding a CUDA implementation of the task is very similar, except that the implementation itself is typically written in CUDA, and compiled with <code>nvcc</code>. Thus, the C file only needs to contain an external declaration for the task implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> vector_scal_cuda (<span class="keywordtype">unsigned</span> size, <span class="keywordtype">float</span> vector[size],</div>
<div class="line">                              <span class="keywordtype">float</span> factor)</div>
<div class="line">  __attribute__ ((task_implementation (<span class="stringliteral">&quot;cuda&quot;</span>, vector_scal)));</div>
</div><!-- fragment --><p>The actual implementation of the CUDA task goes into a separate compilation unit, in a <code>.cu</code> file. It is very close to the implementation when using StarPU's standard C API (<a class="el" href="BasicExamples.html#DefinitionOfTheCUDAKernel">Definition of the CUDA Kernel</a>).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* CUDA implementation of the `vector_scal&#39; task, to be compiled with `nvcc&#39;. */</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt;starpu.h&gt;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;#include &lt;stdlib.h&gt;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;static __global__ void</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;vector_mult_cuda (unsigned n, float *val, float factor)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;{</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  unsigned i = blockIdx.x * blockDim.x + threadIdx.x;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  if (i &lt; n)</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    val[i] *= factor;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;/* Definition of the task implementation declared in the C file. */</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;extern &quot;C&quot; void</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;vector_scal_cuda (size_t size, float vector[], float factor)</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;{</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  unsigned threads_per_block = 64;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  unsigned nblocks = (size + threads_per_block - 1) / threads_per_block;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  vector_mult_cuda &lt;&lt;&lt; nblocks, threads_per_block, 0,</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    starpu_cuda_get_local_stream () &gt;&gt;&gt; (size, vector, factor);</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  cudaStreamSynchronize (starpu_cuda_get_local_stream ());</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;}</div>
</div><!-- fragment --><p> The complete source code, in the directory <code>gcc-plugin/examples/vector_scal</code> of the StarPU distribution, also shows how an SSE-specialized CPU task implementation can be added.</p>
<p>For more details on the C extensions provided by StarPU's GCC plug-in, see <a class="el" href="cExtensions.html">C Extensions</a>.</p>
<h1><a class="anchor" id="VectorScalingUsingStarPUAPI"></a>
Vector Scaling Using StarPU's API</h1>
<p>This section shows how to achieve the same result as explained in the previous section using StarPU's standard C API.</p>
<p>The full source code for this example is given in <a class="el" href="FullSourceCodeVectorScal.html">Full source code for the ’Scaling a Vector’ example</a>.</p>
<h2><a class="anchor" id="SourceCodeOfVectorScaling"></a>
Source Code of Vector Scaling</h2>
<p>Programmers can describe the data layout of their application so that StarPU is responsible for enforcing data coherency and availability across the machine. Instead of handling complex (and non-portable) mechanisms to perform data movements, programmers only declare which piece of data is accessed and/or modified by a task, and StarPU makes sure that when a computational kernel starts somewhere (e.g. on a GPU), its data are available locally.</p>
<p>Before submitting those tasks, the programmer first needs to declare the different pieces of data to StarPU using the functions <code>starpu_*_data_register</code>. To ease the development of applications for StarPU, it is possible to describe multiple types of data layout. A type of data layout is called an <b>interface</b>. There are different predefined interfaces available in StarPU: here we will consider the <b>vector interface</b>.</p>
<p>The following lines show how to declare an array of <code>NX</code> elements of type <code>float</code> using the vector interface:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> vector[NX];</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> vector_handle;</div>
<div class="line"><a class="code" href="group__API__Data__Interfaces.html#ga98ea4083ac39db45b6be75354e66bca1">starpu_vector_data_register</a>(&amp;vector_handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t)vector, NX,</div>
<div class="line">                            <span class="keyword">sizeof</span>(vector[0]));</div>
</div><!-- fragment --><p>The first argument, called the <b>data handle</b>, is an opaque pointer which designates the array in StarPU. This is also the structure which is used to describe which data is used by a task. The second argument is the node number where the data originally resides. Here it is STARPU_MAIN_RAM since the array <code>vector</code> is in the main memory. Then comes the pointer <code>vector</code> where the data can be found in main memory, the number of elements in the vector and the size of each element. The following shows how to construct a StarPU task that will manipulate the vector and a constant factor.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> factor = 3.14;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> *task = <a class="code" href="group__API__Codelet__And__Tasks.html#ga8720143096f8274be1b6ae75a1abd0ed">starpu_task_create</a>();</div>
<div class="line"></div>
<div class="line">task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a> = &amp;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a>;                      <span class="comment">/* Pointer to the codelet defined below */</span></div>
<div class="line">task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#af3ce0252f1ac2238325033386a726df3">handles</a>[0] = vector_handle;    <span class="comment">/* First parameter of the codelet */</span></div>
<div class="line">task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#a08dfa6e007d0ada924ac388679ec2b91">cl_arg</a> = &amp;factor;</div>
<div class="line">task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#adac9af88fed23241fc65259712352126">cl_arg_size</a> = <span class="keyword">sizeof</span>(factor);</div>
<div class="line">task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#a18439d7a6d4ad65b75c75ec02d60075e">synchronous</a> = 1;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div>
</div><!-- fragment --><p>Since the factor is a mere constant float value parameter, it does not need a preliminary registration, and can just be passed through the pointer <a class="el" href="group__API__Codelet__And__Tasks.html#a08dfa6e007d0ada924ac388679ec2b91">starpu_task::cl_arg</a> like in the previous example. The vector parameter is described by its handle. <a class="el" href="group__API__Codelet__And__Tasks.html#af3ce0252f1ac2238325033386a726df3">starpu_task::handles</a> should be set with the handles of the data, the access modes for the data are defined in the field <a class="el" href="group__API__Codelet__And__Tasks.html#a680eeffb0ba785eeb203a8ad2e2870da">starpu_codelet::modes</a> (<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a> for read-only, <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba052ab75035ca297c7955363c605231c8">STARPU_W</a> for write-only and <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a> for read and write access).</p>
<p>The definition of the codelet can be written as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> scal_cpu_func(<span class="keywordtype">void</span> *buffers[], <span class="keywordtype">void</span> *<a class="code" href="group__API__Codelet__And__Tasks.html#a08dfa6e007d0ada924ac388679ec2b91">cl_arg</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span> i;</div>
<div class="line">    <span class="keywordtype">float</span> *factor = <a class="code" href="group__API__Codelet__And__Tasks.html#a08dfa6e007d0ada924ac388679ec2b91">cl_arg</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* length of the vector */</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n = <a class="code" href="group__API__Data__Interfaces.html#ga7cc322b2f03830ec7afbb58b7416a283">STARPU_VECTOR_GET_NX</a>(buffers[0]);</div>
<div class="line">    <span class="comment">/* CPU copy of the vector pointer */</span></div>
<div class="line">    <span class="keywordtype">float</span> *val = (<span class="keywordtype">float</span> *)<a class="code" href="group__API__Data__Interfaces.html#gaa23416a6d049b276fe57b19e069b68b3">STARPU_VECTOR_GET_PTR</a>(buffers[0]);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)</div>
<div class="line">        val[i] *= *factor;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> cl =</div>
<div class="line">{</div>
<div class="line">    .<a class="code" href="group__API__Codelet__And__Tasks.html#a593418a8961318e4085177abeeaa43ad">cpu_funcs</a> = { scal_cpu_func },</div>
<div class="line">    .cpu_funcs_name = { <span class="stringliteral">&quot;scal_cpu_func&quot;</span> },</div>
<div class="line">    .nbuffers = 1,</div>
<div class="line">    .modes = { <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a> }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The first argument is an array that gives a description of all the buffers passed in the array <a class="el" href="group__API__Codelet__And__Tasks.html#af3ce0252f1ac2238325033386a726df3">starpu_task::handles</a>. The size of this array is given by the field <a class="el" href="group__API__Codelet__And__Tasks.html#a1bb02f890f2e10c348499dbd92b56496">starpu_codelet::nbuffers</a>. For the sake of genericity, this array contains pointers to the different interfaces describing each buffer. In the case of the <b>vector interface</b>, the location of the vector (resp. its length) is accessible in the <a class="el" href="group__API__Data__Interfaces.html#a763e990c19520a68ebde783297107a2b">starpu_vector_interface::ptr</a> (resp. <a class="el" href="group__API__Data__Interfaces.html#ad9ae80b9516186ddfd6ee34b74c85674">starpu_vector_interface::nx</a>) of this interface. Since the vector is accessed in a read-write fashion, any modification will automatically affect future accesses to this vector made by other tasks.</p>
<p>The second argument of the function <code>scal_cpu_func</code> contains a pointer to the parameters of the codelet (given in <a class="el" href="group__API__Codelet__And__Tasks.html#a08dfa6e007d0ada924ac388679ec2b91">starpu_task::cl_arg</a>), so that we read the constant factor from this pointer.</p>
<h2><a class="anchor" id="ExecutionOfVectorScaling"></a>
Execution of Vector Scaling</h2>
<pre class="fragment">$ make vector_scal
cc $(pkg-config --cflags starpu-1.2) vector_scal.c -o vector_scal $(pkg-config --libs starpu-1.2)
$ ./vector_scal
0.000000 3.000000 6.000000 9.000000 12.000000
</pre><h1><a class="anchor" id="VectorScalingOnAnHybridCPUGPUMachine"></a>
Vector Scaling on an Hybrid CPU/GPU Machine</h1>
<p>Contrary to the previous examples, the task submitted in this example may not only be executed by the CPUs, but also by a CUDA device.</p>
<h2><a class="anchor" id="DefinitionOfTheCUDAKernel"></a>
Definition of the CUDA Kernel</h2>
<p>The CUDA implementation can be written as follows. It needs to be compiled with a CUDA compiler such as nvcc, the NVIDIA CUDA compiler driver. It must be noted that the vector pointer returned by <a class="el" href="group__API__Data__Interfaces.html#gaa23416a6d049b276fe57b19e069b68b3">STARPU_VECTOR_GET_PTR</a> is here a pointer in GPU memory, so that it can be passed as such to the kernel call <code>vector_mult_cuda</code>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;starpu.h&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;static __global__ void vector_mult_cuda(unsigned n, float *val,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;                                        float factor)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        unsigned i =  blockIdx.x*blockDim.x + threadIdx.x;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        if (i &lt; n)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;               val[i] *= factor;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;extern &quot;C&quot; void scal_cuda_func(void *buffers[], void *_args)</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;{</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        float *factor = (float *)_args;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        /* length of the vector */</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        unsigned n = STARPU_VECTOR_GET_NX(buffers[0]);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        /* local copy of the vector pointer */</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        float *val = (float *)STARPU_VECTOR_GET_PTR(buffers[0]);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        unsigned threads_per_block = 64;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        unsigned nblocks = (n + threads_per_block-1) / threads_per_block;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        vector_mult_cuda&lt;&lt;&lt;nblocks,threads_per_block, 0, starpu_cuda_get_local_stream()&gt;&gt;&gt;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;                   (n, val, *factor);</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        cudaStreamSynchronize(starpu_cuda_get_local_stream());</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;}</div>
</div><!-- fragment --> <h2><a class="anchor" id="DefinitionOfTheOpenCLKernel"></a>
Definition of the OpenCL Kernel</h2>
<p>The OpenCL implementation can be written as follows. StarPU provides tools to compile a OpenCL kernel stored in a file.</p>
<div class="fragment"><div class="line">__kernel <span class="keywordtype">void</span> vector_mult_opencl(<span class="keywordtype">int</span> nx, __global <span class="keywordtype">float</span>* val, <span class="keywordtype">float</span> factor)</div>
<div class="line">{</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> i = get_global_id(0);</div>
<div class="line">        <span class="keywordflow">if</span> (i &lt; nx) {</div>
<div class="line">                val[i] *= factor;</div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Contrary to CUDA and CPU, <a class="el" href="group__API__Data__Interfaces.html#gadccf196d01dd9c43e931827a86f886b2">STARPU_VECTOR_GET_DEV_HANDLE</a> has to be used, which returns a <code>cl_mem</code> (which is not a device pointer, but an OpenCL handle), which can be passed as such to the OpenCL kernel. The difference is important when using partitioning, see <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="starpu_8h.html">starpu.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="group__API__OpenCL__Extensions.html#structstarpu__opencl__program">starpu_opencl_program</a> <a class="code" href="group__API__OpenCL__Extensions.html#a685357d9709ece920bf269a917ed8297">programs</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> scal_opencl_func(<span class="keywordtype">void</span> *buffers[], <span class="keywordtype">void</span> *_args)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> *factor = _args;</div>
<div class="line">    <span class="keywordtype">int</span> id, devid, err;                   <span class="comment">/* OpenCL specific code */</span></div>
<div class="line">    cl_kernel kernel;                     <span class="comment">/* OpenCL specific code */</span></div>
<div class="line">    cl_command_queue queue;               <span class="comment">/* OpenCL specific code */</span></div>
<div class="line">    cl_event event;                       <span class="comment">/* OpenCL specific code */</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">/* length of the vector */</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> n = <a class="code" href="group__API__Data__Interfaces.html#ga7cc322b2f03830ec7afbb58b7416a283">STARPU_VECTOR_GET_NX</a>(buffers[0]);</div>
<div class="line">    <span class="comment">/* OpenCL copy of the vector pointer */</span></div>
<div class="line">    cl_mem val = (cl_mem)<a class="code" href="group__API__Data__Interfaces.html#gadccf196d01dd9c43e931827a86f886b2">STARPU_VECTOR_GET_DEV_HANDLE</a>(buffers[0]);</div>
<div class="line"></div>
<div class="line">    {  <span class="comment">/* OpenCL specific code */</span></div>
<div class="line">         <span class="keywordtype">id</span> = <a class="code" href="group__API__Workers__Properties.html#gac6d06f4e22b63bf50bc8e836cf16f81f">starpu_worker_get_id</a>();</div>
<div class="line">         devid = <a class="code" href="group__API__Workers__Properties.html#ga0c9b9b7f5195cb8cbc5ee1223ec0f264">starpu_worker_get_devid</a>(<span class="keywordtype">id</span>);</div>
<div class="line"></div>
<div class="line">         err = <a class="code" href="group__API__OpenCL__Extensions.html#ga1d06b6c00b15f4fcd8d4c0c998f955ac">starpu_opencl_load_kernel</a>(&amp;kernel, &amp;queue,</div>
<div class="line">                                         &amp;<a class="code" href="group__API__OpenCL__Extensions.html#a685357d9709ece920bf269a917ed8297">programs</a>,</div>
<div class="line">                                         <span class="stringliteral">&quot;vector_mult_opencl&quot;</span>, <span class="comment">/* Name of the codelet */</span></div>
<div class="line">                                         devid);</div>
<div class="line">         <span class="keywordflow">if</span> (err != CL_SUCCESS) <a class="code" href="group__API__OpenCL__Extensions.html#ga6680ed21ce09f073fa0256169f4e4868">STARPU_OPENCL_REPORT_ERROR</a>(err);</div>
<div class="line"></div>
<div class="line">         err = clSetKernelArg(kernel, 0, <span class="keyword">sizeof</span>(n), &amp;n);</div>
<div class="line">         err |= clSetKernelArg(kernel, 1, <span class="keyword">sizeof</span>(val), &amp;val);</div>
<div class="line">         err |= clSetKernelArg(kernel, 2, <span class="keyword">sizeof</span>(*factor), factor);</div>
<div class="line">         <span class="keywordflow">if</span> (err) <a class="code" href="group__API__OpenCL__Extensions.html#ga6680ed21ce09f073fa0256169f4e4868">STARPU_OPENCL_REPORT_ERROR</a>(err);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    {   <span class="comment">/* OpenCL specific code */</span></div>
<div class="line">        <span class="keywordtype">size_t</span> global=n;</div>
<div class="line">        <span class="keywordtype">size_t</span> local;</div>
<div class="line">        <span class="keywordtype">size_t</span> s;</div>
<div class="line">        cl_device_id device;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__API__OpenCL__Extensions.html#ga84a524eaac758722f083ee129a19a567">starpu_opencl_get_device</a>(devid, &amp;device);</div>
<div class="line">        err = clGetKernelWorkGroupInfo (kernel, device, CL_KERNEL_WORK_GROUP_SIZE,</div>
<div class="line">                                        <span class="keyword">sizeof</span>(local), &amp;local, &amp;s);</div>
<div class="line">        <span class="keywordflow">if</span> (err != CL_SUCCESS) <a class="code" href="group__API__OpenCL__Extensions.html#ga6680ed21ce09f073fa0256169f4e4868">STARPU_OPENCL_REPORT_ERROR</a>(err);</div>
<div class="line">        <span class="keywordflow">if</span> (local &gt; global) local=global;</div>
<div class="line"></div>
<div class="line">        err = clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &amp;global, &amp;local, 0,</div>
<div class="line">                                     NULL, &amp;event);</div>
<div class="line">        <span class="keywordflow">if</span> (err != CL_SUCCESS) <a class="code" href="group__API__OpenCL__Extensions.html#ga6680ed21ce09f073fa0256169f4e4868">STARPU_OPENCL_REPORT_ERROR</a>(err);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    {  <span class="comment">/* OpenCL specific code */</span></div>
<div class="line">         clFinish(queue);</div>
<div class="line">         <a class="code" href="group__API__OpenCL__Extensions.html#gaeaabc8e5d90531a21a8307c06c659984">starpu_opencl_collect_stats</a>(event);</div>
<div class="line">         clReleaseEvent(event);</div>
<div class="line"></div>
<div class="line">         <a class="code" href="group__API__OpenCL__Extensions.html#ga68adf424491ec715e891000fa4a6030d">starpu_opencl_release_kernel</a>(kernel);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="DefinitionOfTheMainCode"></a>
Definition of the Main Code</h2>
<p>The CPU implementation is the same as in the previous section.</p>
<p>Here is the source of the main application. You can notice that the fields <a class="el" href="group__API__Codelet__And__Tasks.html#aa6a8436117176270c5372d4dfb006a1f">starpu_codelet::cuda_funcs</a> and <a class="el" href="group__API__Codelet__And__Tasks.html#a757a9831b9e2b5e0d503e902d9f94529">starpu_codelet::opencl_funcs</a> are set to define the pointers to the CUDA and OpenCL implementations of the task.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * This example demonstrates how to use StarPU to scale an array by a factor.</span></div>
<div class="line"><span class="comment"> * It shows how to manipulate data with StarPU&#39;s data management library.</span></div>
<div class="line"><span class="comment"> *  1- how to declare a piece of data to StarPU (starpu_vector_data_register)</span></div>
<div class="line"><span class="comment"> *  2- how to describe which data are accessed by a task (task-&gt;handles[0])</span></div>
<div class="line"><span class="comment"> *  3- how a kernel can manipulate the data (buffers[0].vector.ptr)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="starpu_8h.html">starpu.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define    NX    2048</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> scal_cpu_func(<span class="keywordtype">void</span> *buffers[], <span class="keywordtype">void</span> *_args);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> scal_sse_func(<span class="keywordtype">void</span> *buffers[], <span class="keywordtype">void</span> *_args);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> scal_cuda_func(<span class="keywordtype">void</span> *buffers[], <span class="keywordtype">void</span> *_args);</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> scal_opencl_func(<span class="keywordtype">void</span> *buffers[], <span class="keywordtype">void</span> *_args);</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> cl = {</div>
<div class="line">    .<a class="code" href="group__API__Codelet__And__Tasks.html#a504b8e20f53f469358eadb1ed800f72c">where</a> = <a class="code" href="group__API__Codelet__And__Tasks.html#gaf577e4415a639beffbc48b65454b88ca">STARPU_CPU</a> | <a class="code" href="group__API__Codelet__And__Tasks.html#ga43c37484ac60c15cd6f45ab25c277213">STARPU_CUDA</a> | <a class="code" href="group__API__Codelet__And__Tasks.html#gaec9e5cdf8ac48607ce4495ded31001d5">STARPU_OPENCL</a>,</div>
<div class="line">    <span class="comment">/* CPU implementation of the codelet */</span></div>
<div class="line">    .cpu_funcs = { scal_cpu_func, scal_sse_func },</div>
<div class="line">    .cpu_funcs_name = { <span class="stringliteral">&quot;scal_cpu_func&quot;</span>, <span class="stringliteral">&quot;scal_sse_func&quot;</span> },</div>
<div class="line"><span class="preprocessor">#ifdef STARPU_USE_CUDA</span></div>
<div class="line">    <span class="comment">/* CUDA implementation of the codelet */</span></div>
<div class="line">    .cuda_funcs = { scal_cuda_func },</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#ifdef STARPU_USE_OPENCL</span></div>
<div class="line">    <span class="comment">/* OpenCL implementation of the codelet */</span></div>
<div class="line">    .opencl_funcs = { scal_opencl_func },</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    .nbuffers = 1,</div>
<div class="line">    .modes = { <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a> }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef STARPU_USE_OPENCL</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="group__API__OpenCL__Extensions.html#structstarpu__opencl__program">starpu_opencl_program</a> <a class="code" href="group__API__OpenCL__Extensions.html#a685357d9709ece920bf269a917ed8297">programs</a>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* We consider a vector of float that is initialized just as any of C</span></div>
<div class="line"><span class="comment">      * data */</span></div>
<div class="line">    <span class="keywordtype">float</span> vector[NX];</div>
<div class="line">    <span class="keywordtype">unsigned</span> i;</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; NX; i++)</div>
<div class="line">        vector[i] = 1.0f;</div>
<div class="line"></div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;BEFORE: First element was %f\n&quot;</span>, vector[0]);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Initialize StarPU with default configuration */</span></div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init</a>(NULL);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef STARPU_USE_OPENCL</span></div>
<div class="line">        <a class="code" href="group__API__OpenCL__Extensions.html#ga3441dd1c6e61717dd81a3a6eb0bf75a8">starpu_opencl_load_opencl_from_file</a>(</div>
<div class="line">               <span class="stringliteral">&quot;examples/basic_examples/vector_scal_opencl_kernel.cl&quot;</span>, &amp;<a class="code" href="group__API__OpenCL__Extensions.html#a685357d9709ece920bf269a917ed8297">programs</a>, NULL);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Tell StaPU to associate the &quot;vector&quot; vector with the &quot;vector_handle&quot;</span></div>
<div class="line"><span class="comment">     * identifier. When a task needs to access a piece of data, it should</span></div>
<div class="line"><span class="comment">     * refer to the handle that is associated to it.</span></div>
<div class="line"><span class="comment">     * In the case of the &quot;vector&quot; data interface:</span></div>
<div class="line"><span class="comment">     *  - the first argument of the registration method is a pointer to the</span></div>
<div class="line"><span class="comment">     *    handle that should describe the data</span></div>
<div class="line"><span class="comment">     *  - the second argument is the memory node where the data (ie. &quot;vector&quot;)</span></div>
<div class="line"><span class="comment">     *    resides initially: STARPU_MAIN_RAM stands for an address in main memory, as</span></div>
<div class="line"><span class="comment">     *    opposed to an adress on a GPU for instance.</span></div>
<div class="line"><span class="comment">     *  - the third argument is the adress of the vector in RAM</span></div>
<div class="line"><span class="comment">     *  - the fourth argument is the number of elements in the vector</span></div>
<div class="line"><span class="comment">     *  - the fifth argument is the size of each element.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <a class="code" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> vector_handle;</div>
<div class="line">    <a class="code" href="group__API__Data__Interfaces.html#ga98ea4083ac39db45b6be75354e66bca1">starpu_vector_data_register</a>(&amp;vector_handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t)vector,</div>
<div class="line">                                NX, <span class="keyword">sizeof</span>(vector[0]));</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> factor = 3.14;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* create a synchronous task: any call to starpu_task_submit will block</span></div>
<div class="line"><span class="comment">      * until it is terminated */</span></div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> *task = <a class="code" href="group__API__Codelet__And__Tasks.html#ga8720143096f8274be1b6ae75a1abd0ed">starpu_task_create</a>();</div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#a18439d7a6d4ad65b75c75ec02d60075e">synchronous</a> = 1;</div>
<div class="line"></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a> = &amp;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* the codelet manipulates one buffer in RW mode */</span></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#af3ce0252f1ac2238325033386a726df3">handles</a>[0] = vector_handle;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* an argument is passed to the codelet, beware that this is a</span></div>
<div class="line"><span class="comment">     * READ-ONLY buffer and that the codelet may be given a pointer to a</span></div>
<div class="line"><span class="comment">     * COPY of the argument */</span></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#a08dfa6e007d0ada924ac388679ec2b91">cl_arg</a> = &amp;factor;</div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#adac9af88fed23241fc65259712352126">cl_arg_size</a> = <span class="keyword">sizeof</span>(factor);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* execute the task on any eligible computational ressource */</span></div>
<div class="line">    <a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* StarPU does not need to manipulate the array anymore so we can stop</span></div>
<div class="line"><span class="comment">      * monitoring it */</span></div>
<div class="line">    <a class="code" href="group__API__Data__Management.html#ga586146498466b60d6b81145dfaeb8948">starpu_data_unregister</a>(vector_handle);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef STARPU_USE_OPENCL</span></div>
<div class="line">    <a class="code" href="group__API__OpenCL__Extensions.html#gaa38e7cb3231ed30303e50f46c8f6e39c">starpu_opencl_unload_opencl</a>(&amp;programs);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">/* terminate StarPU, no task can be submitted after */</span></div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown</a>();</div>
<div class="line"></div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;AFTER First element is %f\n&quot;</span>, vector[0]);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="ExecutionOfHybridVectorScaling"></a>
Execution of Hybrid Vector Scaling</h2>
<p>The Makefile given at the beginning of the section must be extended to give the rules to compile the CUDA source code. Note that the source file of the OpenCL kernel does not need to be compiled now, it will be compiled at run-time when calling the function <a class="el" href="group__API__OpenCL__Extensions.html#ga3441dd1c6e61717dd81a3a6eb0bf75a8">starpu_opencl_load_opencl_from_file()</a>.</p>
<pre class="fragment">CFLAGS  += $(shell pkg-config --cflags starpu-1.2)
LDFLAGS += $(shell pkg-config --libs starpu-1.2)
CC       = gcc

vector_scal: vector_scal.o vector_scal_cpu.o vector_scal_cuda.o vector_scal_opencl.o

%.o: %.cu
       nvcc $(CFLAGS) $&lt; -c $@

clean:
       rm -f vector_scal *.o
</pre><pre class="fragment">$ make
</pre><p>and to execute it, with the default configuration:</p>
<pre class="fragment">$ ./vector_scal
0.000000 3.000000 6.000000 9.000000 12.000000
</pre><p>or for example, by disabling CPU devices:</p>
<pre class="fragment">$ STARPU_NCPU=0 ./vector_scal
0.000000 3.000000 6.000000 9.000000 12.000000
</pre><p>or by disabling CUDA devices (which may permit to enable the use of OpenCL, see <a class="el" href="BuildingAndInstallingStarPU.html#EnablingOpenCL">Enabling OpenCL</a>) :</p>
<pre class="fragment">$ STARPU_NCUDA=0 ./vector_scal
0.000000 3.000000 6.000000 9.000000 12.000000
</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 6 2015 21:13:08 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
