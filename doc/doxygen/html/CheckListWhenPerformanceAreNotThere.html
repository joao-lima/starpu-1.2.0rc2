<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>StarPU Handbook: Check List When Performance Are Not There</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('CheckListWhenPerformanceAreNotThere.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Check List When Performance Are Not There </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>TODO: improve!</p>
<p>Simply encapsulating application kernels into tasks already permits to seamlessly support CPU and GPUs at the same time. To achieve good performance, we give below a list of features which should be checked.</p>
<h1><a class="anchor" id="DataRelatedFeaturesToImprovePerformance"></a>
Data Related Features That May Improve Performance</h1>
<p>link to <a class="el" href="DataManagement.html#DataManagement">Data Management</a></p>
<p>link to <a class="el" href="DataManagement.html#DataPrefetch">Data Prefetch</a></p>
<h1><a class="anchor" id="TaskRelatedFeaturesToImprovePerformance"></a>
Task Related Features That May Improve Performance</h1>
<p>link to <a class="el" href="TasksInStarPU.html#TaskGranularity">Task Granularity</a></p>
<p>link to <a class="el" href="TasksInStarPU.html#TaskSubmission">Task Submission</a></p>
<p>link to <a class="el" href="TasksInStarPU.html#TaskPriorities">Task Priorities</a></p>
<h1><a class="anchor" id="SchedulingRelatedFeaturesToImprovePerformance"></a>
Scheduling Related Features That May Improve Performance</h1>
<p>link to <a class="el" href="Scheduling.html#TaskSchedulingPolicy">Task Scheduling Policy</a></p>
<p>link to <a class="el" href="Scheduling.html#TaskDistributionVsDataTransfer">Task Distribution Vs Data Transfer</a></p>
<p>link to <a class="el" href="Scheduling.html#Power-basedScheduling">Power-based Scheduling</a></p>
<p>link to <a class="el" href="Scheduling.html#StaticScheduling">Static Scheduling</a></p>
<h1><a class="anchor" id="CUDA-specificOptimizations"></a>
CUDA-specific Optimizations</h1>
<p>Due to CUDA limitations, StarPU will have a hard time overlapping its own communications and the codelet computations if the application does not use a dedicated CUDA stream for its computations instead of the default stream, which synchronizes all operations of the GPU. StarPU provides one by the use of <a class="el" href="group__API__CUDA__Extensions.html#gad7d80d054bd2b9570e1d7e24442e19c0">starpu_cuda_get_local_stream()</a> which can be used by all CUDA codelet operations to avoid this issue. For instance:</p>
<div class="fragment"><div class="line">func &lt;&lt;&lt;grid,block,0,starpu_cuda_get_local_stream()&gt;&gt;&gt; (foo, bar);</div>
<div class="line">cudaStreamSynchronize(<a class="code" href="group__API__CUDA__Extensions.html#gad7d80d054bd2b9570e1d7e24442e19c0">starpu_cuda_get_local_stream</a>());</div>
</div><!-- fragment --><p>Unfortunately, some CUDA libraries do not have stream variants of kernels. That will lower the potential for overlapping.</p>
<p>Calling <a class="el" href="group__API__CUDA__Extensions.html#ga9f70358bd39f2228d7b0558702306d96">starpu_cublas_init()</a> makes StarPU already do appropriate calls for the CUBLAS library. Some libraries like Magma may however change the current stream, one then has to call cublasSetKernelStream(starpu_cuda_get_local_stream()); at the beginning of the codelet to make sure that CUBLAS is really using the proper stream.</p>
<p>If the kernel can be made to only use this local stream or other self-allocated streams, i.e. the whole kernel submission can be made asynchronous, then one should enable asynchronous execution of the kernel. That means setting the flag <a class="el" href="starpu__task_8h.html#ac91ae22b428595d3956a1c2225e2621e">STARPU_CUDA_ASYNC</a> in the corresponding field <a class="el" href="group__API__Codelet__And__Tasks.html#aaa458493da38622be2713700f3c96a5d">starpu_codelet::cuda_flags</a>, and dropping the cudaStreamSynchronize() call at the end of the cuda_func function, so that it returns immediately after having queued the kernel to the local stream. That way, StarPU will be able to submit and complete data transfers while kernels are executing, instead of only at each kernel submission. The kernel just has to make sure that StarPU can use the local stream to synchronize with the kernel startup and completion.</p>
<p>Using the flag <a class="el" href="starpu__task_8h.html#ac91ae22b428595d3956a1c2225e2621e">STARPU_CUDA_ASYNC</a> also permits to enable concurrent kernel execution, on cards which support it (Kepler and later, notably). This is enabled by setting the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NWORKER_PER_CUDA">STARPU_NWORKER_PER_CUDA</a> to the number of kernels to execute concurrently. This is useful when kernels are small and do not feed the whole GPU with threads to run.</p>
<h1><a class="anchor" id="OpenCL-specificOptimizations"></a>
OpenCL-specific Optimizations</h1>
<p>If the kernel can be made to only use the StarPU-provided command queue or other self-allocated queues, i.e. the whole kernel submission can be made asynchronous, then one should enable asynchronous execution of the kernel. This means setting the flag <a class="el" href="starpu__task_8h.html#a3c2546614b19e43aad2bed0d935b38b4">STARPU_OPENCL_ASYNC</a> in the corresponding field <a class="el" href="group__API__Codelet__And__Tasks.html#a2de77d2c65169749809c078367905a93">starpu_codelet::opencl_flags</a> and dropping the clFinish() and <a class="el" href="group__API__OpenCL__Extensions.html#gaeaabc8e5d90531a21a8307c06c659984">starpu_opencl_collect_stats()</a> calls at the end of the kernel, so that it returns immediately after having queued the kernel to the provided queue. That way, StarPU will be able to submit and complete data transfers while kernels are executing, instead of only at each kernel submission. The kernel just has to make sure that StarPU can use the command queue it has provided to synchronize with the kernel startup and completion.</p>
<h1><a class="anchor" id="DetectionStuckConditions"></a>
Detection Stuck Conditions</h1>
<p>It may happen that for some reason, StarPU does not make progress for a long period of time. Reason are sometimes due to contention inside StarPU, but sometimes this is due to external reasons, such as stuck MPI driver, or CUDA driver, etc.</p>
<p><code>export STARPU_WATCHDOG_TIMEOUT=10000</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WATCHDOG_TIMEOUT">STARPU_WATCHDOG_TIMEOUT</a>)</p>
<p>allows to make StarPU print an error message whenever StarPU does not terminate any task for 10ms. In addition to that,</p>
<p><code>export STARPU_WATCHDOG_CRASH=1</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WATCHDOG_CRASH">STARPU_WATCHDOG_CRASH</a>)</p>
<p>raises SIGABRT in that condition, thus allowing to catch the situation in gdb. It can also be useful to type "handle SIGABRT nopass" in gdb to be able to let the process continue, after inspecting the state of the process.</p>
<h1><a class="anchor" id="HowToLimitMemoryPerNode"></a>
How to limit memory per node</h1>
<p>TODO</p>
<p>Talk about <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CUDA_devid_MEM">STARPU_LIMIT_CUDA_devid_MEM</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CUDA_MEM">STARPU_LIMIT_CUDA_MEM</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_OPENCL_devid_MEM">STARPU_LIMIT_OPENCL_devid_MEM</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_OPENCL_MEM">STARPU_LIMIT_OPENCL_MEM</a> and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CPU_MEM">STARPU_LIMIT_CPU_MEM</a></p>
<p><a class="el" href="group__API__Standard__Memory__Library.html#gaccfcb477defdecd13c2d2471e9810c6b">starpu_memory_get_total()</a></p>
<p><a class="el" href="group__API__Standard__Memory__Library.html#ga897b57b3349c1d495eeb144d64ff12c3">starpu_memory_get_available()</a></p>
<h1><a class="anchor" id="HowToReduceTheMemoryFootprintOfInternalDataStructures"></a>
How To Reduce The Memory Footprint Of Internal Data Structures</h1>
<p>It is possible to reduce the memory footprint of the task and data internal structures of StarPU by describing the shape of your machine and/or your application at the configure step.</p>
<p>To reduce the memory footprint of the data internal structures of StarPU, one can set the <a class="el" href="CompilationConfiguration.html#enable-maxcpus">--enable-maxcpus</a>, <a class="el" href="CompilationConfiguration.html#enable-maxcudadev">--enable-maxcudadev</a>, <a class="el" href="CompilationConfiguration.html#enable-maxopencldev">--enable-maxopencldev</a> and <a class="el" href="CompilationConfiguration.html#enable-maxnodes">--enable-maxnodes</a> configure parameters to give StarPU the architecture of the machine it will run on, thus tuning the size of the structures to the machine.</p>
<p>To reduce the memory footprint of the task internal structures of StarPU, one can set the <a class="el" href="CompilationConfiguration.html#enable-maxbuffers">--enable-maxbuffers</a> configure parameter to give StarPU the maximum number of buffers that a task can use during an execution. For example, in the Cholesky factorization (dense linear algebra application), the GEMM task uses up to 3 buffers, so it is possible to set the maximum number of task buffers to 3 to run a Cholesky factorization on StarPU.</p>
<h1><a class="anchor" id="HowtoReuseMemory"></a>
How to reuse memory</h1>
<p>When your application needs to allocate more data than the available amount of memory usable by StarPU (given by <a class="el" href="group__API__Standard__Memory__Library.html#ga897b57b3349c1d495eeb144d64ff12c3">starpu_memory_get_available()</a> ), the allocation cache system can reuse data buffers used by previously executed tasks. For that system to work with MPI tasks, you need to submit tasks progressively instead of as soon as possible, because in the case of MPI receives, the allocation cache check for reusing data buffers will be done at submission time, not at execution time.</p>
<p>You have two options to control the task submission flow. The first one is by controlling the number of submitted tasks during the whole execution. This can be done whether by setting the environment variables <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_MAX_NSUBMITTED_TASKS">STARPU_LIMIT_MAX_NSUBMITTED_TASKS</a> and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_MIN_NSUBMITTED_TASKS">STARPU_LIMIT_MIN_NSUBMITTED_TASKS</a> to tell StarPU when to stop submitting tasks and when to wake up and submit tasks again, or by explicitely calling <a class="el" href="group__API__Codelet__And__Tasks.html#ga724cda8b0ffeaa7532a5e573b86bc90b">starpu_task_wait_for_n_submitted()</a> in your application code for finest grain control (for example, between two iterations of a submission loop).</p>
<p>The second option is to control the memory size of the allocation cache. This can be done in the application by using jointly <a class="el" href="group__API__Standard__Memory__Library.html#ga897b57b3349c1d495eeb144d64ff12c3">starpu_memory_get_available()</a> and <a class="el" href="group__API__Standard__Memory__Library.html#ga71ec84f082fd96f53612e684eda0e178">starpu_memory_wait_available()</a> to submit tasks only when there is enough memory space to allocate the data needed by the task, i.e when enough data are available for reuse in the allocation cache.</p>
<h1><a class="anchor" id="PerformanceModelCalibration"></a>
Performance Model Calibration</h1>
<p>Most schedulers are based on an estimation of codelet duration on each kind of processing unit. For this to be possible, the application programmer needs to configure a performance model for the codelets of the application (see <a class="el" href="OnlinePerformanceTools.html#PerformanceModelExample">Performance Model Example</a> for instance). History-based performance models use on-line calibration. StarPU will automatically calibrate codelets which have never been calibrated yet, and save the result in <code>$STARPU_HOME/.starpu/sampling/codelets</code>. The models are indexed by machine name. To share the models between machines (e.g. for a homogeneous cluster), use <code>export STARPU_HOSTNAME=some_global_name</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_HOSTNAME">STARPU_HOSTNAME</a>). To force continuing calibration, use <code>export STARPU_CALIBRATE=1</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_CALIBRATE">STARPU_CALIBRATE</a>). This may be necessary if your application has not-so-stable performance. StarPU will force calibration (and thus ignore the current result) until 10 (<code>_STARPU_CALIBRATION_MINIMUM</code>) measurements have been made on each architecture, to avoid badly scheduling tasks just because the first measurements were not so good. Details on the current performance model status can be obtained from the command <code>starpu_perfmodel_display</code>: the <code>-l</code> option lists the available performance models, and the <code>-s</code> option permits to choose the performance model to be displayed. The result looks like:</p>
<pre class="fragment">$ starpu_perfmodel_display -s starpu_slu_lu_model_11
performance model for cpu_impl_0
# hash    size     flops         mean          dev           n
914f3bef  1048576  0.000000e+00  2.503577e+04  1.982465e+02  8
3e921964  65536    0.000000e+00  5.527003e+02  1.848114e+01  7
e5a07e31  4096     0.000000e+00  1.717457e+01  5.190038e+00  14
...
</pre><p>Which shows that for the LU 11 kernel with a 1MiB matrix, the average execution time on CPUs was about 25ms, with a 0.2ms standard deviation, over 8 samples. It is a good idea to check this before doing actual performance measurements.</p>
<p>A graph can be drawn by using the tool <code>starpu_perfmodel_plot</code>:</p>
<pre class="fragment">$ starpu_perfmodel_plot -s starpu_slu_lu_model_11
4096 16384 65536 262144 1048576 4194304 
$ gnuplot starpu_starpu_slu_lu_model_11.gp
$ gv starpu_starpu_slu_lu_model_11.eps
</pre><div class="image">
<img src="starpu_starpu_slu_lu_model_11.png" alt="starpu_starpu_slu_lu_model_11.png"/>
</div>
 <p>If a kernel source code was modified (e.g. performance improvement), the calibration information is stale and should be dropped, to re-calibrate from start. This can be done by using <code>export STARPU_CALIBRATE=2</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_CALIBRATE">STARPU_CALIBRATE</a>).</p>
<p>Note: history-based performance models get calibrated only if a performance-model-based scheduler is chosen.</p>
<p>The history-based performance models can also be explicitly filled by the application without execution, if e.g. the application already has a series of measurements. This can be done by using <a class="el" href="group__API__Performance__Model.html#gaecb9341bff471557abbb63a966449481">starpu_perfmodel_update_history()</a>, for instance:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="group__API__Performance__Model.html#structstarpu__perfmodel">starpu_perfmodel</a> perf_model = {</div>
<div class="line">    .<a class="code" href="group__API__Performance__Model.html#afe2d561aaba7bf1ad1cf03974ee8c53c">type</a> = <a class="code" href="group__API__Performance__Model.html#ggae161a7cae376f3fc831a2b764e8144e6a61a1a08e950abce6779d8eaee6cfe395">STARPU_HISTORY_BASED</a>,</div>
<div class="line">    .symbol = <span class="stringliteral">&quot;my_perfmodel&quot;</span>,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> cl = {</div>
<div class="line">    .<a class="code" href="group__API__Codelet__And__Tasks.html#aa6a8436117176270c5372d4dfb006a1f">cuda_funcs</a> = { cuda_func1, cuda_func2 },</div>
<div class="line">    .nbuffers = 1,</div>
<div class="line">    .modes = {<a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba052ab75035ca297c7955363c605231c8">STARPU_W</a>},</div>
<div class="line">    .model = &amp;perf_model</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> feed(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">struct </span>my_measure *measure;</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> task;</div>
<div class="line">    <a class="code" href="group__API__Codelet__And__Tasks.html#gadf8b76ef62ba0e68684e07ebf1db1731">starpu_task_init</a>(&amp;task);</div>
<div class="line"></div>
<div class="line">    task.<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a> = &amp;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (measure = &amp;measures[0]; measure &lt; measures[last]; measure++) {</div>
<div class="line">        <a class="code" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle;</div>
<div class="line">        <a class="code" href="group__API__Data__Interfaces.html#ga98ea4083ac39db45b6be75354e66bca1">starpu_vector_data_register</a>(&amp;handle, -1, 0, measure-&gt;size, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line">        task.<a class="code" href="group__API__Codelet__And__Tasks.html#af3ce0252f1ac2238325033386a726df3">handles</a>[0] = handle;</div>
<div class="line">        <a class="code" href="group__API__Performance__Model.html#gaecb9341bff471557abbb63a966449481">starpu_perfmodel_update_history</a>(&amp;perf_model, &amp;task,</div>
<div class="line">                                        STARPU_CUDA_DEFAULT + measure-&gt;cudadev, 0,</div>
<div class="line">                                        measure-&gt;implementation, measure-&gt;time);</div>
<div class="line">        <a class="code" href="group__API__Codelet__And__Tasks.html#gaecb3efa04cb10b049b10c6166dd9c30c">starpu_task_clean</a>(&amp;task);</div>
<div class="line">        <a class="code" href="group__API__Data__Management.html#ga586146498466b60d6b81145dfaeb8948">starpu_data_unregister</a>(handle);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Measurement has to be provided in milliseconds for the completion time models, and in Joules for the energy consumption models.</p>
<h1><a class="anchor" id="Profiling"></a>
Profiling</h1>
<p>A quick view of how many tasks each worker has executed can be obtained by setting <code>export STARPU_WORKER_STATS=1</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKER_STATS">STARPU_WORKER_STATS</a>). This is a convenient way to check that execution did happen on accelerators, without penalizing performance with the profiling overhead.</p>
<p>A quick view of how much data transfers have been issued can be obtained by setting <code>export STARPU_BUS_STATS=1</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_BUS_STATS">STARPU_BUS_STATS</a>).</p>
<p>More detailed profiling information can be enabled by using <code>export STARPU_PROFILING=1</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_PROFILING">STARPU_PROFILING</a>) or by calling <a class="el" href="group__API__Profiling.html#gabeb22bbe8062a45507cfc6273aae51ae">starpu_profiling_status_set()</a> from the source code. Statistics on the execution can then be obtained by using <code>export STARPU_BUS_STATS=1</code> and <code>export STARPU_WORKER_STATS=1</code> . More details on performance feedback are provided in the next chapter. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 6 2015 21:13:09 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
