<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>StarPU Handbook: Out Of Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__API__Out__Of__Core.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Out Of Core</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structstarpu__disk__ops"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a></td></tr>
<tr class="separator:structstarpu__disk__ops"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac9ed48246cb2b326ca6a199b6183aa75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#gac9ed48246cb2b326ca6a199b6183aa75">starpu_disk_register</a> (struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a> *func, void *parameter, starpu_ssize_t size)</td></tr>
<tr class="separator:gac9ed48246cb2b326ca6a199b6183aa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddcdc1beb6f41ed8d38778fb51cc0e6d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#gaddcdc1beb6f41ed8d38778fb51cc0e6d">starpu_disk_open</a> (unsigned node, void *pos, size_t size)</td></tr>
<tr class="separator:gaddcdc1beb6f41ed8d38778fb51cc0e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd566efd70ad57cda18a6b9a7be4ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga8cd566efd70ad57cda18a6b9a7be4ac7">starpu_disk_close</a> (unsigned node, void *obj, size_t size)</td></tr>
<tr class="separator:ga8cd566efd70ad57cda18a6b9a7be4ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5bb135a02ac97b9efa9ab0280a604868"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga5bb135a02ac97b9efa9ab0280a604868">starpu_disk_stdio_ops</a></td></tr>
<tr class="separator:ga5bb135a02ac97b9efa9ab0280a604868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647a9db1632791e9410643658ad50ffd"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga647a9db1632791e9410643658ad50ffd">starpu_disk_unistd_ops</a></td></tr>
<tr class="separator:ga647a9db1632791e9410643658ad50ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902a7c5a3920a874f6e4db36c86c1e4b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga902a7c5a3920a874f6e4db36c86c1e4b">starpu_disk_unistd_o_direct_ops</a></td></tr>
<tr class="separator:ga902a7c5a3920a874f6e4db36c86c1e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1bd09de991de1491afa05f5e528e94"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga4a1bd09de991de1491afa05f5e528e94">starpu_disk_leveldb_ops</a></td></tr>
<tr class="separator:ga4a1bd09de991de1491afa05f5e528e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structstarpu__disk__ops" id="structstarpu__disk__ops"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct starpu_disk_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This is a set of functions to manipulate datas on disk. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a5c9a2e621b2245d2b9a684b94dbc1dea"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a5c9a2e621b2245d2b9a684b94dbc1dea">plug</a> )(void *parameter, starpu_ssize_t size)</td></tr>
<tr class="separator:a5c9a2e621b2245d2b9a684b94dbc1dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1b835b2c5dceb66d254ebfbb9c8641"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#aad1b835b2c5dceb66d254ebfbb9c8641">unplug</a> )(void *base)</td></tr>
<tr class="separator:aad1b835b2c5dceb66d254ebfbb9c8641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288de4b6f4c98dd092ea61400d8707b3"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a288de4b6f4c98dd092ea61400d8707b3">bandwidth</a> )(unsigned node)</td></tr>
<tr class="separator:a288de4b6f4c98dd092ea61400d8707b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961bb551927dba496faa49eecb1bc038"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a961bb551927dba496faa49eecb1bc038">alloc</a> )(void *base, size_t size)</td></tr>
<tr class="separator:a961bb551927dba496faa49eecb1bc038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f728320480e5d25d8994f35d22ee44"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a48f728320480e5d25d8994f35d22ee44">free</a> )(void *base, void *obj, size_t size)</td></tr>
<tr class="separator:a48f728320480e5d25d8994f35d22ee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36a0753adcf848d1ebc921d861d8596"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ae36a0753adcf848d1ebc921d861d8596">open</a> )(void *base, void *pos, size_t size)</td></tr>
<tr class="separator:ae36a0753adcf848d1ebc921d861d8596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cd099afd9d1e13db2a6fd0f7492444"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ab6cd099afd9d1e13db2a6fd0f7492444">close</a> )(void *base, void *obj, size_t size)</td></tr>
<tr class="separator:ab6cd099afd9d1e13db2a6fd0f7492444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0553e3a7ebc9e2b758bd899a1daa1ee"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ab0553e3a7ebc9e2b758bd899a1daa1ee">read</a> )(void *base, void *obj, void *buf, off_t offset, size_t size)</td></tr>
<tr class="separator:ab0553e3a7ebc9e2b758bd899a1daa1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13aed2b7fdca833d2f0048bd5fa7a2c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#af13aed2b7fdca833d2f0048bd5fa7a2c">write</a> )(void *base, void *obj, const void *buf, off_t offset, size_t size)</td></tr>
<tr class="separator:af13aed2b7fdca833d2f0048bd5fa7a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7987ae5399f0ad84f4ecadbd8245d8aa"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a7987ae5399f0ad84f4ecadbd8245d8aa">full_read</a> )(void *base, void *obj, void **ptr, size_t *size)</td></tr>
<tr class="separator:a7987ae5399f0ad84f4ecadbd8245d8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffd343dbc9ede17d031afe95a9330ba"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a1ffd343dbc9ede17d031afe95a9330ba">full_write</a> )(void *base, void *obj, void *ptr, size_t size)</td></tr>
<tr class="separator:a1ffd343dbc9ede17d031afe95a9330ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb20d34b157e2ba7e440cf956c2fdcea"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#aeb20d34b157e2ba7e440cf956c2fdcea">async_write</a> )(void *base, void *obj, void *buf, off_t offset, size_t size)</td></tr>
<tr class="separator:aeb20d34b157e2ba7e440cf956c2fdcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a4ebefcef246101a918d98f5d7b434"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a20a4ebefcef246101a918d98f5d7b434">async_read</a> )(void *base, void *obj, void *buf, off_t offset, size_t size)</td></tr>
<tr class="separator:a20a4ebefcef246101a918d98f5d7b434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7908803880126fdd01315d8426cd0649"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a7908803880126fdd01315d8426cd0649">async_full_read</a> )(void *base, void *obj, void **ptr, size_t *size)</td></tr>
<tr class="separator:a7908803880126fdd01315d8426cd0649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0388b7a7f7f7b0e221eb2af8975ece"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a2d0388b7a7f7f7b0e221eb2af8975ece">async_full_write</a> )(void *base, void *obj, void *ptr, size_t size)</td></tr>
<tr class="separator:a2d0388b7a7f7f7b0e221eb2af8975ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de6e65b6acc90d8fff377f90dd50563"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a8de6e65b6acc90d8fff377f90dd50563">copy</a> )(void *base_src, void *obj_src, off_t offset_src, void *base_dst, void *obj_dst, off_t offset_dst, size_t size)</td></tr>
<tr class="separator:a8de6e65b6acc90d8fff377f90dd50563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df8ee8098d6304314f95a448cbf8822"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a9df8ee8098d6304314f95a448cbf8822">wait_request</a> )(void *async_channel)</td></tr>
<tr class="separator:a9df8ee8098d6304314f95a448cbf8822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f3ab7262523ecde01e75fa80fff32f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ac6f3ab7262523ecde01e75fa80fff32f">test_request</a> )(void *async_channel)</td></tr>
<tr class="separator:ac6f3ab7262523ecde01e75fa80fff32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9bc28f2e7af2aa4d0aa666e1ef0bee"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a2b9bc28f2e7af2aa4d0aa666e1ef0bee">free_request</a> )(void *async_channel)</td></tr>
<tr class="separator:a2b9bc28f2e7af2aa4d0aa666e1ef0bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a5c9a2e621b2245d2b9a684b94dbc1dea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* starpu_disk_ops::plug)(void *parameters, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a disk memory at location <code>parameter</code> with size <code>size</code>, and return a base as void*, which will be passed by StarPU to all other methods. </p>

</div>
</div>
<a class="anchor" id="aad1b835b2c5dceb66d254ebfbb9c8641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::unplug)(void *base)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnect a disk memory <code>base</code>. </p>

</div>
</div>
<a class="anchor" id="a288de4b6f4c98dd092ea61400d8707b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::bandwidth)(unsigned node)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Measure the bandwidth and the latency for the disk <code>node</code> and save it. Returns 1 if it could measure it. </p>

</div>
</div>
<a class="anchor" id="a961bb551927dba496faa49eecb1bc038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* starpu_disk_ops::alloc)(void *base, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new location for datas of size <code>size</code>. This returns an opaque object pointer. </p>

</div>
</div>
<a class="anchor" id="a48f728320480e5d25d8994f35d22ee44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::free)(void *base, void *obj, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a data <code>obj</code> previously allocated with <code>alloc</code>. </p>

</div>
</div>
<a class="anchor" id="ae36a0753adcf848d1ebc921d861d8596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* starpu_disk_ops::open)(void *base, void *pos, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open an existing location of datas, at a specific position <code>pos</code> dependent on the backend. </p>

</div>
</div>
<a class="anchor" id="ab6cd099afd9d1e13db2a6fd0f7492444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::close)(void *base, void *obj, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close, without deleting it, a location of datas <code>obj</code>. </p>

</div>
</div>
<a class="anchor" id="ab0553e3a7ebc9e2b758bd899a1daa1ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::read)(void *base, void *obj, void *buf, off_t offset, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read <code>size</code> bytes of data from <code>obj</code> in <code>base</code>, at offset <code>offset</code>, and put into <code>buf</code>. Returns the actual number of read bytes. </p>

</div>
</div>
<a class="anchor" id="af13aed2b7fdca833d2f0048bd5fa7a2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::write)(void *base, void *obj, const void *buf, off_t offset, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write <code>size</code> bytes of data to <code>obj</code> in <code>base</code>, at offset <code>offset</code>, from <code>buf</code>. Returns 0 on success. </p>

</div>
</div>
<a class="anchor" id="a7987ae5399f0ad84f4ecadbd8245d8aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::full_read)(void *base, void *obj, void **ptr, size_t *size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read all data from <code>obj</code> of <code>base</code>, from offset 0. Returns it in an allocated buffer <code>ptr</code>, of size <code>size</code> </p>

</div>
</div>
<a class="anchor" id="a1ffd343dbc9ede17d031afe95a9330ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::full_write)(void *base, void *obj, void *ptr, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data in <code>ptr</code> to <code>obj</code> of <code>base</code>, from offset 0, and truncate <code>obj</code> to <code>size</code>, so that a <code>full_read</code> will get it. </p>

</div>
</div>
<a class="anchor" id="aeb20d34b157e2ba7e440cf956c2fdcea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* starpu_disk_ops::async_write)(void *base, void *obj, const void *buf, off_t offset, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronously write <code>size</code> bytes of data to <code>obj</code> in <code>base</code>, at offset <code>offset</code>, from <code>buf</code>. Returns a void* pointer that StarPU will pass to <code>_request</code> methods for testing for the completion. </p>

</div>
</div>
<a class="anchor" id="a20a4ebefcef246101a918d98f5d7b434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* starpu_disk_ops::async_read)(void *base, void *obj, void *buf, off_t offset, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronously read <code>size</code> bytes of data from <code>obj</code> in <code>base</code>, at offset <code>offset</code>, and put into <code>buf</code>. Returns a void* pointer that StarPU will pass to <code>_request</code> methods for testing for the completion. </p>

</div>
</div>
<a class="anchor" id="a7908803880126fdd01315d8426cd0649"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* starpu_disk_ops::async_full_read)(void *base, void *obj, void **ptr, size_t *size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read all data from <code>obj</code> of <code>base</code>, from offset 0. Returns it in an allocated buffer <code>ptr</code>, of size <code>size</code> </p>

</div>
</div>
<a class="anchor" id="a2d0388b7a7f7f7b0e221eb2af8975ece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* starpu_disk_ops::async_full_write)(void *base, void *obj, void *ptr, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data in <code>ptr</code> to <code>obj</code> of <code>base</code>, from offset 0, and truncate <code>obj</code> to <code>size</code>, so that a <code>full_read</code> will get it. </p>

</div>
</div>
<a class="anchor" id="a8de6e65b6acc90d8fff377f90dd50563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* starpu_disk_ops::copy)(void *base_src, void *obj_src, off_t offset_src, void *base_dst, void *obj_dst, off_t offset_dst, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy from offset <code>offset_src</code> of disk object <code>obj_src</code> in <code>base_src</code> to offset <code>offset_dst</code> of disk object <code>obj_dst</code> in <code>base_dst</code>. Returns a void* pointer that StarPU will pass to <code>*_request</code> methods for testing for the completion. </p>

</div>
</div>
<a class="anchor" id="a9df8ee8098d6304314f95a448cbf8822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::wait_request)(void *async_channel)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for completion of request <code>async_channel</code> returned by a previous asynchronous read, write or copy. </p>

</div>
</div>
<a class="anchor" id="ac6f3ab7262523ecde01e75fa80fff32f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::test_request)(void *async_channel)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for completion of request <code>async_channel</code> returned by a previous asynchronous read, write or copy. Returns 1 on completion, 0 otherwise. </p>

</div>
</div>
<a class="anchor" id="a2b9bc28f2e7af2aa4d0aa666e1ef0bee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::free_request)(void *async_channel)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the request allocated by a previous asynchronous read, write or copy. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac9ed48246cb2b326ca6a199b6183aa75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_disk_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">starpu_ssize_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a disk memory node with a set of functions to manipulate datas. The <code>plug</code> member of <code>func</code> will be passed <code>parameter</code>, and return a <code>base</code> which will be passed to all <code>func</code> methods. <br />
 SUCCESS: return the disk node. <br />
 FAIL: return an error code. <br />
 The <code>size</code> must be at least 1 MB ! <code>size</code> being negative means infinite size. </p>

</div>
</div>
<a class="anchor" id="gaddcdc1beb6f41ed8d38778fb51cc0e6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * starpu_disk_open </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open an existing file memory in a disk node. <code>size:</code> this is a size of your file. <code>pos</code> is specific position dependent on the backend, given to the <code>open</code> method of the disk operations. This returns an opaque object pointer. </p>

</div>
</div>
<a class="anchor" id="ga8cd566efd70ad57cda18a6b9a7be4ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_disk_close </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an existing data opened with starpu_disk_open. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga5bb135a02ac97b9efa9ab0280a604868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">starpu_disk_stdio_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This set uses the stdio library (fwrite, fread...) to read/write on disk. <br />
 <b>Warning: It creates one file per allocation !</b> <br />
 It doesn't support asynchronous transfers. </p>

</div>
</div>
<a class="anchor" id="ga647a9db1632791e9410643658ad50ffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">starpu_disk_unistd_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This set uses the unistd library (write, read...) to read/write on disk. <br />
 <b>Warning: It creates one file per allocation !</b> <br />
 </p>

</div>
</div>
<a class="anchor" id="ga902a7c5a3920a874f6e4db36c86c1e4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">starpu_disk_unistd_o_direct_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This set uses the unistd library (write, read...) to read/write on disk with the O_DIRECT flag. <br />
 <b>Warning: It creates one file per allocation !</b> <br />
 Only available on Linux systems. </p>

</div>
</div>
<a class="anchor" id="ga4a1bd09de991de1491afa05f5e528e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">starpu_disk_leveldb_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This set uses the leveldb created by Google <br />
 Show here: <a href="https://code.google.com/p/leveldb/">https://code.google.com/p/leveldb/</a> <br />
 It doesn't support asynchronous transfers. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 6 2015 21:13:12 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
