<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>StarPU Handbook: C Extensions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('cExtensions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">C Extensions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>When GCC plug-in support is available, StarPU builds a plug-in for the GNU Compiler Collection (GCC), which defines extensions to languages of the C family (C, C++, Objective-C) that make it easier to write StarPU code. This feature is only available for GCC 4.5 and later; it is known to work with GCC 4.5, 4.6, and 4.7. You may need to install a specific <code>-dev</code> package of your distro, such as <code>gcc-4.6-plugin-dev</code> on Debian and derivatives. In addition, the plug-in's test suite is only run when GNU Guile (<a href="http://www.gnu.org/software/guile/">http://www.gnu.org/software/guile/</a>) is found at <code>configure</code>-time. Building the GCC plug-in can be disabled by configuring with <a class="el" href="CompilationConfiguration.html#disable-gcc-extensions">--disable-gcc-extensions</a>.</p>
<p>Those extensions include syntactic sugar for defining tasks and their implementations, invoking a task, and manipulating data buffers. Use of these extensions can be made conditional on the availability of the plug-in, leading to valid C sequential code when the plug-in is not used (<a class="el" href="cExtensions.html#UsingCExtensionsConditionally">Using C Extensions Conditionally</a>).</p>
<p>When StarPU has been installed with its GCC plug-in, programs that use these extensions can be compiled this way:</p>
<pre class="fragment">$ gcc -c -fplugin=`pkg-config starpu-1.2 --variable=gccplugin` foo.c
</pre><p>When the plug-in is not available, the above <code>pkg-config</code> command returns the empty string.</p>
<p>In addition, the <code>-fplugin-arg-starpu-verbose</code> flag can be used to obtain feedback from the compiler as it analyzes the C extensions used in source files.</p>
<p>This section describes the C extensions implemented by StarPU's GCC plug-in. It does not require detailed knowledge of the StarPU library.</p>
<p>Note: this is still an area under development and subject to change.</p>
<h1><a class="anchor" id="DefiningTasks"></a>
Defining Tasks</h1>
<p>The StarPU GCC plug-in views tasks as ``extended'' C functions:</p>
<ul>
<li>
tasks may have several implementations&mdash;e.g., one for CPUs, one written in OpenCL, one written in CUDA;  </li>
<li>
tasks may have several implementations of the same target&mdash;e.g., several CPU implementations;  </li>
<li>
when a task is invoked, it may run in parallel, and StarPU is free to choose any of its implementations.  </li>
</ul>
<p>Tasks and their implementations must be <em>declared</em>. These declarations are annotated with attributes (<a href="http://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax">http://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html#Attribute-Syntax</a>): the declaration of a task is a regular C function declaration with an additional <code>task</code> attribute, and task implementations are declared with a <code>task_implementation</code> attribute.</p>
<p>The following function attributes are provided:</p>
<dl>
<dt><code>task</code> </dt>
<dd><p class="startdd">Declare the given function as a StarPU task. Its return type must be <code>void</code>. When a function declared as <code>task</code> has a user-defined body, that body is interpreted as the implicit definition of the task's CPU implementation (see example below). In all cases, the actual definition of a task's body is automatically generated by the compiler.</p>
<p>Under the hood, declaring a task leads to the declaration of the corresponding <code>codelet</code> (<a class="el" href="index.html#CodeletAndTasks">Codelet and Tasks</a>). If one or more task implementations are declared in the same compilation unit, then the codelet and the function itself are also defined; they inherit the scope of the task.</p>
<p>Scalar arguments to the task are passed by value and copied to the target device if need be&mdash;technically, they are passed as the buffer <a class="el" href="group__API__Codelet__And__Tasks.html#a08dfa6e007d0ada924ac388679ec2b91">starpu_task::cl_arg</a> (<a class="el" href="index.html#CodeletAndTasks">Codelet and Tasks</a>).</p>
<p>Pointer arguments are assumed to be registered data buffers&mdash;the handles argument of a task (<a class="el" href="group__API__Codelet__And__Tasks.html#af3ce0252f1ac2238325033386a726df3">starpu_task::handles</a>) ; <code>const</code>-qualified pointer arguments are viewed as read-only buffers (<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>), and non-<code>const</code>-qualified buffers are assumed to be used read-write (<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a>). In addition, the <code>output</code> type attribute can be as a type qualifier for output pointer or array parameters (<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba052ab75035ca297c7955363c605231c8">STARPU_W</a>). </p>
<p class="enddd"></p>
</dd>
<dt><code>task_implementation (target, task)</code> </dt>
<dd><p class="startdd">Declare the given function as an implementation of <code>task</code> to run on <code>target</code>. <code>target</code> must be a string, currently one of <code>"cpu"</code>, <code>"opencl"</code>, or <code>"cuda"</code>.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>Here is an example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define __output  __attribute__ ((output))</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> matmul (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B,</div>
<div class="line">                    __output <span class="keywordtype">float</span> *C,</div>
<div class="line">                    <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">  __attribute__ ((task));</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> matmul_cpu (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B,</div>
<div class="line">                        __output <span class="keywordtype">float</span> *C,</div>
<div class="line">                        <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">  __attribute__ ((task_implementation (<span class="stringliteral">&quot;cpu&quot;</span>, matmul)));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">matmul_cpu (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, __output <span class="keywordtype">float</span> *C,</div>
<div class="line">            <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">unsigned</span> i, j, k;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (j = 0; j &lt; ny; j++)</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; nx; i++)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">for</span> (k = 0; k &lt; nz; k++)</div>
<div class="line">          C[j * nx + i] += A[j * nz + k] * B[k * nx + i];</div>
<div class="line">      }</div>
<div class="line">}</div>
</div><!-- fragment --><p>A <code>matmult</code> task is defined; it has only one implementation, <code>matmult_cpu</code>, which runs on the CPU. Variables <code>A</code> and <code>B</code> are input buffers, whereas <code>C</code> is considered an input/output buffer.</p>
<p>For convenience, when a function declared with the <code>task</code> attribute has a user-defined body, that body is assumed to be that of the CPU implementation of a task, which we call an implicit task CPU implementation. Thus, the above snippet can be simplified like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define __output  __attribute__ ((output))</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> matmul (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B,</div>
<div class="line">                    __output <span class="keywordtype">float</span> *C,</div>
<div class="line">                    <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">  __attribute__ ((task));</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Implicit definition of the CPU implementation of the</span></div>
<div class="line"><span class="comment">   `matmul&#39; task.  */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">matmul (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, __output <span class="keywordtype">float</span> *C,</div>
<div class="line">        <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">unsigned</span> i, j, k;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (j = 0; j &lt; ny; j++)</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; nx; i++)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">for</span> (k = 0; k &lt; nz; k++)</div>
<div class="line">          C[j * nx + i] += A[j * nz + k] * B[k * nx + i];</div>
<div class="line">      }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Use of implicit CPU task implementations as above has the advantage that the code is valid sequential code when StarPU's GCC plug-in is not used (<a class="el" href="cExtensions.html#UsingCExtensionsConditionally">Using C Extensions Conditionally</a>).</p>
<p>CUDA and OpenCL implementations can be declared in a similar way:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> matmul_cuda (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, <span class="keywordtype">float</span> *C,</div>
<div class="line">                         <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">  __attribute__ ((task_implementation (<span class="stringliteral">&quot;cuda&quot;</span>, matmul)));</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> matmul_opencl (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, <span class="keywordtype">float</span> *C,</div>
<div class="line">                           <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">  __attribute__ ((task_implementation (<span class="stringliteral">&quot;opencl&quot;</span>, matmul)));</div>
</div><!-- fragment --><p>The CUDA and OpenCL implementations typically either invoke a kernel written in CUDA or OpenCL (for similar code, <a class="el" href="FullSourceCodeVectorScal.html#CUDAKernel">CUDA Kernel</a>, and <a class="el" href="FullSourceCodeVectorScal.html#OpenCLKernel">OpenCL Kernel</a>), or call a library function that uses CUDA or OpenCL under the hood, such as CUBLAS functions:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">matmul_cuda (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, <span class="keywordtype">float</span> *C,</div>
<div class="line">             <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">{</div>
<div class="line">  cublasSgemm (<span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;n&#39;</span>, nx, ny, nz,</div>
<div class="line">               1.0f, A, 0, B, 0,</div>
<div class="line">               0.0f, C, 0);</div>
<div class="line">  cudaStreamSynchronize (<a class="code" href="group__API__CUDA__Extensions.html#gad7d80d054bd2b9570e1d7e24442e19c0">starpu_cuda_get_local_stream</a> ());</div>
<div class="line">}</div>
</div><!-- fragment --><p>A task can be invoked like a regular C function:</p>
<div class="fragment"><div class="line">matmul (&amp;A[i * zdim * bydim + k * bzdim * bydim],</div>
<div class="line">        &amp;B[k * xdim * bzdim + j * bxdim * bzdim],</div>
<div class="line">        &amp;C[i * xdim * bydim + j * bxdim * bydim],</div>
<div class="line">        bxdim, bydim, bzdim);</div>
</div><!-- fragment --><p>This leads to an asynchronous invocation, whereby <code>matmult</code>'s implementation may run in parallel with the continuation of the caller.</p>
<p>The next section describes how memory buffers must be handled in StarPU-GCC code. For a complete example, see the <code>gcc-plugin/examples</code> directory of the source distribution, and <a class="el" href="BasicExamples.html#VectorScalingUsingTheCExtension">Vector Scaling Using the C Extension</a>.</p>
<h1><a class="anchor" id="InitializationTerminationAndSynchronization"></a>
Initialization, Termination, and Synchronization</h1>
<p>The following pragmas allow user code to control StarPU's life time and to synchronize with tasks.</p>
<dl>
<dt><code>#pragma starpu initialize</code> </dt>
<dd><p class="startdd">Initialize StarPU. This call is compulsory and is <em>never</em> added implicitly. One of the reasons this has to be done explicitly is that it provides greater control to user code over its resource usage. </p>
<p class="enddd"></p>
</dd>
<dt><code>#pragma starpu shutdown</code> </dt>
<dd><p class="startdd">Shut down StarPU, giving it an opportunity to write profiling info to a file on disk, for instance (<a class="el" href="OfflinePerformanceTools.html#Off-linePerformanceFeedback">Off-line Performance Feedback</a>). </p>
<p class="enddd"></p>
</dd>
<dt><code>#pragma starpu wait</code> </dt>
<dd>Wait for all task invocations to complete, as with <a class="el" href="group__API__Codelet__And__Tasks.html#gad0baa8dbfd13e5a7bc3651bcd76022aa">starpu_task_wait_for_all()</a>.  </dd>
</dl>
<h1><a class="anchor" id="RegisteredDataBuffers"></a>
Registered Data Buffers</h1>
<p>Data buffers such as matrices and vectors that are to be passed to tasks must be registered. Registration allows StarPU to handle data transfers among devices&mdash;e.g., transferring an input buffer from the CPU's main memory to a task scheduled to run a GPU (<a class="el" href="index.html#StarPUDataManagementLibrary">StarPU Data Management Library</a>).</p>
<p>The following pragmas are provided:</p>
<dl>
<dt><code>#pragma starpu register ptr [size]</code> </dt>
<dd><p class="startdd">Register <code>ptr</code> as a <code>size</code>-element buffer. When <code>ptr</code> has an array type whose size is known, <code>size</code> may be omitted. Alternatively, the <code>registered</code> attribute can be used (see below.) </p>
<p class="enddd"></p>
</dd>
<dt><code>#pragma starpu unregister ptr</code> </dt>
<dd><p class="startdd">Unregister the previously-registered memory area pointed to by <code>ptr</code>. As a side-effect, <code>ptr</code> points to a valid copy in main memory. </p>
<p class="enddd"></p>
</dd>
<dt><code>#pragma starpu acquire ptr</code> </dt>
<dd><p class="startdd">Acquire in main memory an up-to-date copy of the previously-registered memory area pointed to by <code>ptr</code>, for read-write access. </p>
<p class="enddd"></p>
</dd>
<dt><code>#pragma starpu release ptr</code> </dt>
<dd>Release the previously-register memory area pointed to by <code>ptr</code>, making it available to the tasks.  </dd>
</dl>
<p>Additionally, the following attributes offer a simple way to allocate and register storage for arrays:</p>
<dl>
<dt><code>registered</code> </dt>
<dd><p class="startdd">This attributes applies to local variables with an array type. Its effect is to automatically register the array's storage, as per <code>#pragma starpu register</code>. The array is automatically unregistered when the variable's scope is left. This attribute is typically used in conjunction with the <code>heap_allocated</code> attribute, described below. </p>
<p class="enddd"></p>
</dd>
<dt><code>heap_allocated</code> </dt>
<dd>This attributes applies to local variables with an array type. Its effect is to automatically allocate the array's storage on the heap, using <a class="el" href="group__API__Standard__Memory__Library.html#ga49603eaea3b05e8ced9ba1bd873070c3">starpu_malloc()</a> under the hood. The heap-allocated array is automatically freed when the variable's scope is left, as with automatic variables.  </dd>
</dl>
<p>The following example illustrates use of the <code>heap_allocated</code> attribute:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> cholesky(<span class="keywordtype">unsigned</span> nblocks, <span class="keywordtype">unsigned</span> size,</div>
<div class="line">                    <span class="keywordtype">float</span> mat[nblocks][nblocks][size])</div>
<div class="line">  __attribute__ ((task));</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#pragma starpu initialize</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* ... */</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span> nblocks, size;</div>
<div class="line">  parse_args (&amp;nblocks, &amp;size);</div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Allocate an array of the required size on the heap,</span></div>
<div class="line"><span class="comment">     and register it.  */</span></div>
<div class="line"></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">float</span> matrix[nblocks][nblocks][size]</div>
<div class="line">      __attribute__ ((heap_allocated, registered));</div>
<div class="line"></div>
<div class="line">    cholesky (nblocks, size, matrix);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#pragma starpu wait</span></div>
<div class="line"></div>
<div class="line">  }   <span class="comment">/* MATRIX is automatically unregistered &amp; freed here.  */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#pragma starpu shutdown</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --> <h1><a class="anchor" id="UsingCExtensionsConditionally"></a>
Using C Extensions Conditionally</h1>
<p>The C extensions described in this chapter are only available when GCC and its StarPU plug-in are in use. Yet, it is possible to make use of these extensions when they are available&mdash;leading to hybrid CPU/GPU code&mdash;and discard them when they are not available&mdash;leading to valid sequential code.</p>
<p>To that end, the GCC plug-in defines the C preprocessor macro &mdash; <code>STARPU_GCC_PLUGIN</code> &mdash; when it is being used. When defined, this macro expands to an integer denoting the version of the supported C extensions.</p>
<p>The code below illustrates how to define a task and its implementations in a way that allows it to be compiled without the GCC plug-in:</p>
<div class="fragment"><div class="line"><span class="comment">/* This program is valid, whether or not StarPU&#39;s GCC plug-in</span></div>
<div class="line"><span class="comment">   is being used.  */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* The attribute below is ignored when GCC is not used.  */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> matmul (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, <span class="keywordtype">float</span> * C,</div>
<div class="line">                    <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">  __attribute__ ((task));</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">matmul (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, <span class="keywordtype">float</span> * C,</div>
<div class="line">        <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">/* Code of the CPU kernel here...  */</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef STARPU_GCC_PLUGIN</span></div>
<div class="line"><span class="comment">/* Optional OpenCL task implementation.  */</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> matmul_opencl (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, <span class="keywordtype">float</span> * C,</div>
<div class="line">                           <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">  __attribute__ ((task_implementation (<span class="stringliteral">&quot;opencl&quot;</span>, matmul)));</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">matmul_opencl (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, <span class="keywordtype">float</span> * C,</div>
<div class="line">               <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">/* Code that invokes the OpenCL kernel here...  */</span></div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="comment">/* The pragmas below are simply ignored when StarPU-GCC</span></div>
<div class="line"><span class="comment">     is not used.  */</span></div>
<div class="line"><span class="preprocessor">#pragma starpu initialize</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">float</span> A[123][42][7], B[123][42][7], C[123][42][7];</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#pragma starpu register A</span></div>
<div class="line"><span class="preprocessor">#pragma starpu register B</span></div>
<div class="line"><span class="preprocessor">#pragma starpu register C</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* When StarPU-GCC is used, the call below is asynchronous;</span></div>
<div class="line"><span class="comment">     otherwise, it is synchronous.  */</span></div>
<div class="line">  matmul ((<span class="keywordtype">float</span> *) A, (<span class="keywordtype">float</span> *) B, (<span class="keywordtype">float</span> *) C, 123, 42, 7);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#pragma starpu wait</span></div>
<div class="line"><span class="preprocessor">#pragma starpu shutdown</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above program is a valid StarPU program when StarPU's GCC plug-in is used; it is also a valid sequential program when the plug-in is not used.</p>
<p>Note that attributes such as <code>task</code> as well as <code>starpu</code> pragmas are simply ignored by GCC when the StarPU plug-in is not loaded. However, <code>gcc -Wall</code> emits a warning for unknown attributes and pragmas, which can be inconvenient. In addition, other compilers may be unable to parse the attribute syntax (In practice, Clang and several proprietary compilers implement attributes.), so you may want to wrap attributes in macros like this:</p>
<div class="fragment"><div class="line"><span class="comment">/* Use the `task&#39; attribute only when StarPU&#39;s GCC plug-in</span></div>
<div class="line"><span class="comment">   is available.   */</span></div>
<div class="line"><span class="preprocessor">#ifdef STARPU_GCC_PLUGIN</span></div>
<div class="line"><span class="preprocessor"># define __task  __attribute__ ((task))</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"># define __task</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> matmul (<span class="keyword">const</span> <span class="keywordtype">float</span> *A, <span class="keyword">const</span> <span class="keywordtype">float</span> *B, <span class="keywordtype">float</span> *C,</div>
<div class="line">                    <span class="keywordtype">unsigned</span> nx, <span class="keywordtype">unsigned</span> ny, <span class="keywordtype">unsigned</span> nz) __task;</div>
</div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 6 2015 21:13:12 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
