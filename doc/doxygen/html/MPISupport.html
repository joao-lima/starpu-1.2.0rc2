<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>StarPU Handbook: MPI Support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('MPISupport.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">MPI Support </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The integration of MPI transfers within task parallelism is done in a very natural way by the means of asynchronous interactions between the application and StarPU. This is implemented in a separate libstarpumpi library which basically provides "StarPU" equivalents of <code>MPI_*</code> functions, where <code>void *</code> buffers are replaced with <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>, and all GPU-RAM-NIC transfers are handled efficiently by StarPU-MPI. The user has to use the usual <code>mpirun</code> command of the MPI implementation to start StarPU on the different MPI nodes.</p>
<p>An MPI Insert Task function provides an even more seamless transition to a distributed application, by automatically issuing all required data transfers according to the task graph and an application-provided distribution.</p>
<h1><a class="anchor" id="SimpleExample"></a>
Simple Example</h1>
<p>The flags required to compile or link against the MPI layer are accessible with the following commands:</p>
<pre class="fragment">$ pkg-config --cflags starpumpi-1.2  # options for the compiler
$ pkg-config --libs starpumpi-1.2    # options for the linker
</pre><p>You also need pass the option <code>&ndash;static</code> if the application is to be linked statically.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> increment_token(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> *task = <a class="code" href="group__API__Codelet__And__Tasks.html#ga8720143096f8274be1b6ae75a1abd0ed">starpu_task_create</a>();</div>
<div class="line"></div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#ac4012012eb243e8d6f6574334dc99460">cl</a> = &amp;increment_cl;</div>
<div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#af3ce0252f1ac2238325033386a726df3">handles</a>[0] = token_handle;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> rank, size;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init</a>(NULL);</div>
<div class="line">    <a class="code" href="group__API__MPI__Support.html#ga234e28905c976ed1b03fcdf75812a06d">starpu_mpi_initialize_extended</a>(&amp;rank, &amp;size);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__API__Data__Interfaces.html#ga98ea4083ac39db45b6be75354e66bca1">starpu_vector_data_register</a>(&amp;token_handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t)&amp;token, 1, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> nloops = NITER;</div>
<div class="line">    <span class="keywordtype">unsigned</span> loop;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> last_loop = nloops - 1;</div>
<div class="line">    <span class="keywordtype">unsigned</span> last_rank = size - 1;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (loop = 0; loop &lt; nloops; loop++) {</div>
<div class="line">        <span class="keywordtype">int</span> tag = loop*size + rank;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (loop == 0 &amp;&amp; rank == 0)</div>
<div class="line">        {</div>
<div class="line">            token = 0;</div>
<div class="line">            fprintf(stdout, <span class="stringliteral">&quot;Start with token value %d\n&quot;</span>, token);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="group__API__MPI__Support.html#gabdf54ffd31c0b0908d7751e1b2257897">starpu_mpi_irecv_detached</a>(token_handle, (rank+size-1)%size, tag,</div>
<div class="line">                    MPI_COMM_WORLD, NULL, NULL);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        increment_token();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (loop == last_loop &amp;&amp; rank == last_rank)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire</a>(token_handle, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>);</div>
<div class="line">            fprintf(stdout, <span class="stringliteral">&quot;Finished: token value %d\n&quot;</span>, token);</div>
<div class="line">            <a class="code" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release</a>(token_handle);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="group__API__MPI__Support.html#gae9506ceb82e72ab1096ac8443dbf13e4">starpu_mpi_isend_detached</a>(token_handle, (rank+1)%size, tag+1,</div>
<div class="line">                    MPI_COMM_WORLD, NULL, NULL);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__API__Codelet__And__Tasks.html#gad0baa8dbfd13e5a7bc3651bcd76022aa">starpu_task_wait_for_all</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__API__MPI__Support.html#ga87b22900dc132a958a0f7bce68d32153">starpu_mpi_shutdown</a>();</div>
<div class="line">    <a class="code" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (rank == last_rank)</div>
<div class="line">    {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;[%d] token = %d == %d * %d ?\n&quot;</span>, rank, token, nloops, size);</div>
<div class="line">        <a class="code" href="group__API__Toolbox.html#ga05ac0dda104331f57d85823a4f9318ce">STARPU_ASSERT</a>(token == nloops*size);</div>
<div class="line">    }</div>
</div><!-- fragment --><h1><a class="anchor" id="PointToPointCommunication"></a>
Point To Point Communication</h1>
<p>The standard point to point communications of MPI have been implemented. The semantic is similar to the MPI one, but adapted to the DSM provided by StarPU. A MPI request will only be submitted when the data is available in the main memory of the node submitting the request.</p>
<p>There is two types of asynchronous communications: the classic asynchronous communications and the detached communications. The classic asynchronous communications (<a class="el" href="group__API__MPI__Support.html#gafc29de4080f202511f2b558673304b8c">starpu_mpi_isend()</a> and <a class="el" href="group__API__MPI__Support.html#gabb6c92b51c1e76408e0816385fde75c5">starpu_mpi_irecv()</a>) need to be followed by a call to <a class="el" href="group__API__MPI__Support.html#gaad03f0a288bad79078045130b9a83188">starpu_mpi_wait()</a> or to <a class="el" href="group__API__MPI__Support.html#gae8e8389eb3e916131946028e9ebee670">starpu_mpi_test()</a> to wait for or to test the completion of the communication. Waiting for or testing the completion of detached communications is not possible, this is done internally by StarPU-MPI, on completion, the resources are automatically released. This mechanism is similar to the pthread detach state attribute which determines whether a thread will be created in a joinable or a detached state.</p>
<p>Internally, all communication are divided in 2 communications, a first message is used to exchange an envelope describing the data (i.e its tag and its size), the data itself is sent in a second message. All MPI communications submitted by StarPU uses a unique tag which has a default value, and can be accessed with the functions <a class="el" href="group__API__MPI__Support.html#ga1d0194c08bd343a68c833f449fb62fa8">starpu_mpi_get_communication_tag()</a> and <a class="el" href="group__API__MPI__Support.html#gaa734bb0c57e4a48a7fe6e41f2e563e68">starpu_mpi_set_communication_tag()</a>. The matching of tags with corresponding requests is done within StarPU-MPI.</p>
<p>For any userland communication, the call of the corresponding function (e.g <a class="el" href="group__API__MPI__Support.html#gafc29de4080f202511f2b558673304b8c">starpu_mpi_isend()</a>) will result in the creation of a StarPU-MPI request, the function <a class="el" href="group__API__Data__Management.html#ga358aba7459b7f99a6dbaa189ce57b925">starpu_data_acquire_cb()</a> is then called to asynchronously request StarPU to fetch the data in main memory; when the data is ready and the corresponding buffer has already been received by MPI, it will be copied in the memory of the data, otherwise the request is stored in the <em>early requests list</em>. Sending requests are stored in the <em>ready requests list</em>.</p>
<p>While requests need to be processed, the StarPU-MPI progression thread does the following:</p>
<ol>
<li>
it polls the <em>ready requests list</em>. For all the ready requests, the appropriate function is called to post the corresponding MPI call. For example, an initial call to <a class="el" href="group__API__MPI__Support.html#gafc29de4080f202511f2b558673304b8c">starpu_mpi_isend()</a> will result in a call to <code>MPI_Isend</code>. If the request is marked as detached, the request will then be added in the <em>detached requests list</em>.  </li>
<li>
it posts a <code>MPI_Irecv()</code> to retrieve a data envelope.  </li>
<li>
it polls the <em>detached requests list</em>. For all the detached requests, it tests its completion of the MPI request by calling <code>MPI_Test</code>. On completion, the data handle is released, and if a callback was defined, it is called.  </li>
<li>
<p class="startli">finally, it checks if a data envelope has been received. If so, if the data envelope matches a request in the <em>early requests list</em> (i.e the request has already been posted by the application), the corresponding MPI call is posted (similarly to the first step above).</p>
<p class="endli">If the data envelope does not match any application request, a temporary handle is created to receive the data, a StarPU-MPI request is created and added into the <em>ready requests list</em>, and thus will be processed in the first step of the next loop.  </p>
</li>
</ol>
<p><a class="el" href="group__API__MPI__Support.html#MPIPtpCommunication">Communication</a> gives the list of all the point to point communications defined in StarPU-MPI.</p>
<h1><a class="anchor" id="ExchangingUserDefinedDataInterface"></a>
Exchanging User Defined Data Interface</h1>
<p>New data interfaces defined as explained in <a class="el" href="DataManagement.html#DefiningANewDataInterface">Defining A New Data Interface</a> can also be used within StarPU-MPI and exchanged between nodes. Two functions needs to be defined through the type <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a>. The function <a class="el" href="group__API__Data__Interfaces.html#a3fd7bff8deaf3056c25424d2d958e60b">starpu_data_interface_ops::pack_data</a> takes a handle and returns a contiguous memory buffer allocated with starpu_malloc_flags(ptr, size, 0) along with its size where data to be conveyed to another node should be copied. The reversed operation is implemented in the function <a class="el" href="group__API__Data__Interfaces.html#aba40ff0a66fefffc49f2440e43a9d98a">starpu_data_interface_ops::unpack_data</a> which takes a contiguous memory buffer and recreates the data handle.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> complex_pack_data(<a class="code" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, <span class="keywordtype">unsigned</span> node, <span class="keywordtype">void</span> **ptr, ssize_t *count)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="group__API__Toolbox.html#ga05ac0dda104331f57d85823a4f9318ce">STARPU_ASSERT</a>(starpu_data_test_if_allocated_on_node(handle, node));</div>
<div class="line"></div>
<div class="line">  <span class="keyword">struct </span>starpu_complex_interface *complex_interface =</div>
<div class="line">    (<span class="keyword">struct </span>starpu_complex_interface *) <a class="code" href="group__API__Data__Interfaces.html#gab6e12b04b231773f2eff496f57d29ee8">starpu_data_get_interface_on_node</a>(handle, node);</div>
<div class="line"></div>
<div class="line">  *count = complex_get_size(handle);</div>
<div class="line">  <a class="code" href="group__API__Standard__Memory__Library.html#gaebaa5a1503be11ba7da92f72a8e601b2">starpu_malloc_flags</a>(ptr, *count, 0);</div>
<div class="line">  memcpy(*ptr, complex_interface-&gt;real, complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line">  memcpy(*ptr+complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>), complex_interface-&gt;imaginary,</div>
<div class="line">         complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> complex_unpack_data(<a class="code" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, <span class="keywordtype">unsigned</span> node, <span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> count)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="group__API__Toolbox.html#ga05ac0dda104331f57d85823a4f9318ce">STARPU_ASSERT</a>(starpu_data_test_if_allocated_on_node(handle, node));</div>
<div class="line"></div>
<div class="line">  <span class="keyword">struct </span>starpu_complex_interface *complex_interface =</div>
<div class="line">    (<span class="keyword">struct </span>starpu_complex_interface *) <a class="code" href="group__API__Data__Interfaces.html#gab6e12b04b231773f2eff496f57d29ee8">starpu_data_get_interface_on_node</a>(handle, node);</div>
<div class="line"></div>
<div class="line">  memcpy(complex_interface-&gt;real, ptr, complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line">  memcpy(complex_interface-&gt;imaginary, ptr+complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),</div>
<div class="line">         complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> interface_complex_ops =</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  .<a class="code" href="group__API__Data__Interfaces.html#a3fd7bff8deaf3056c25424d2d958e60b">pack_data</a> = complex_pack_data,</div>
<div class="line">  .unpack_data = complex_unpack_data</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="MPIInsertTaskUtility"></a>
MPI Insert Task Utility</h1>
<p>To save the programmer from having to explicit all communications, StarPU provides an "MPI Insert Task Utility". The principe is that the application decides a distribution of the data over the MPI nodes by allocating it and notifying StarPU of that decision, i.e. tell StarPU which MPI node "owns" which data. It also decides, for each handle, an MPI tag which will be used to exchange the content of the handle. All MPI nodes then process the whole task graph, and StarPU automatically determines which node actually execute which task, and trigger the required MPI transfers.</p>
<p>The list of functions is described in <a class="el" href="group__API__MPI__Support.html#MPIInsertTask">MPI Insert Task</a>.</p>
<p>Here an stencil example showing how to use <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a>. One first needs to define a distribution function which specifies the locality of the data. Note that the data needs to be registered to MPI by calling <a class="el" href="group__API__MPI__Support.html#gac45e4d77c3d077955bcdc6e1bf0e8cd8">starpu_mpi_data_register()</a>. This function allows to set the distribution information and the MPI tag which should be used when communicating the data. It also allows to automatically clear the MPI communication cache when unregistering the data.</p>
<div class="fragment"><div class="line"><span class="comment">/* Returns the MPI node number where data is */</span></div>
<div class="line"><span class="keywordtype">int</span> my_distrib(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> nb_nodes) {</div>
<div class="line">  <span class="comment">/* Block distrib */</span></div>
<div class="line">  <span class="keywordflow">return</span> ((<span class="keywordtype">int</span>)(x / sqrt(nb_nodes) + (y / sqrt(nb_nodes)) * sqrt(nb_nodes))) % nb_nodes;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// /* Other examples useful for other kinds of computations */</span></div>
<div class="line">  <span class="comment">// /* / distrib */</span></div>
<div class="line">  <span class="comment">// return (x+y) % nb_nodes;</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// /* Block cyclic distrib */</span></div>
<div class="line">  <span class="comment">// unsigned side = sqrt(nb_nodes);</span></div>
<div class="line">  <span class="comment">// return x % side + (y % side) * size;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Now the data can be registered within StarPU. Data which are not owned but will be needed for computations can be registered through the lazy allocation mechanism, i.e. with a <code>home_node</code> set to <code>-1</code>. StarPU will automatically allocate the memory when it is used for the first time.</p>
<p>One can note an optimization here (the <code>else if</code> test): we only register data which will be needed by the tasks that we will execute.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> matrix[X][Y];</div>
<div class="line"><a class="code" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> data_handles[X][Y];</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; X; x++) {</div>
<div class="line">    <span class="keywordflow">for</span> (y = 0; y &lt; Y; y++) {</div>
<div class="line">        <span class="keywordtype">int</span> mpi_rank = my_distrib(x, y, size);</div>
<div class="line">        <span class="keywordflow">if</span> (mpi_rank == my_rank)</div>
<div class="line">            <span class="comment">/* Owning data */</span></div>
<div class="line">            <a class="code" href="group__API__Data__Interfaces.html#gadcd1aee7fb7226edebe64dfcc46c1d69">starpu_variable_data_register</a>(&amp;data_handles[x][y], <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>,</div>
<div class="line">                                          (uintptr_t)&amp;(matrix[x][y]), <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_rank == my_distrib(x+1, y, size) || my_rank == my_distrib(x-1, y, size)</div>
<div class="line">              || my_rank == my_distrib(x, y+1, size) || my_rank == my_distrib(x, y-1, size))</div>
<div class="line">            <span class="comment">/* I don&#39;t own that index, but will need it for my computations */</span></div>
<div class="line">            <a class="code" href="group__API__Data__Interfaces.html#gadcd1aee7fb7226edebe64dfcc46c1d69">starpu_variable_data_register</a>(&amp;data_handles[x][y], -1,</div>
<div class="line">                                          (uintptr_t)NULL, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            <span class="comment">/* I know it&#39;s useless to allocate anything for this */</span></div>
<div class="line">            data_handles[x][y] = NULL;</div>
<div class="line">        <span class="keywordflow">if</span> (data_handles[x][y]) {</div>
<div class="line">            <a class="code" href="group__API__MPI__Support.html#gac45e4d77c3d077955bcdc6e1bf0e8cd8">starpu_mpi_data_register</a>(data_handles[x][y], x*X+y, mpi_rank);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a> can be called for the different steps of the application.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(loop=0 ; loop&lt;niter; loop++)</div>
<div class="line">    <span class="keywordflow">for</span> (x = 1; x &lt; X-1; x++)</div>
<div class="line">        <span class="keywordflow">for</span> (y = 1; y &lt; Y-1; y++)</div>
<div class="line">            <a class="code" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert</a>(MPI_COMM_WORLD, &amp;stencil5_cl,</div>
<div class="line">                                   <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a>, data_handles[x][y],</div>
<div class="line">                                   <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[x-1][y],</div>
<div class="line">                                   <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[x+1][y],</div>
<div class="line">                                   <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[x][y-1],</div>
<div class="line">                                   <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[x][y+1],</div>
<div class="line">                                   0);</div>
<div class="line"><a class="code" href="group__API__Codelet__And__Tasks.html#gad0baa8dbfd13e5a7bc3651bcd76022aa">starpu_task_wait_for_all</a>();</div>
</div><!-- fragment --><p>I.e. all MPI nodes process the whole task graph, but as mentioned above, for each task, only the MPI node which owns the data being written to (here, <code>data_handles[x][y]</code>) will actually run the task. The other MPI nodes will automatically send the required data.</p>
<p>This can be a concern with a growing number of nodes. To avoid this, the application can prune the task for loops according to the data distribution, so as to only submit tasks on nodes which have to care about them (either to execute them, or to send the required data).</p>
<p>A way to do some of this quite easily can be to just add an <code>if</code> like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(loop=0 ; loop&lt;niter; loop++)</div>
<div class="line">    <span class="keywordflow">for</span> (x = 1; x &lt; X-1; x++)</div>
<div class="line">        <span class="keywordflow">for</span> (y = 1; y &lt; Y-1; y++)</div>
<div class="line">            <span class="keywordflow">if</span> (my_distrib(x,y,size) == my_rank</div>
<div class="line">             || my_distrib(x-1,y,size) == my_rank</div>
<div class="line">             || my_distrib(x+1,y,size) == my_rank</div>
<div class="line">             || my_distrib(x,y-1,size) == my_rank</div>
<div class="line">             || my_distrib(x,y+1,size) == my_rank)</div>
<div class="line">                <a class="code" href="group__API__MPI__Support.html#ga04229edbc905be8eefce8fb58bfccf8f">starpu_mpi_insert_task</a>(MPI_COMM_WORLD, &amp;stencil5_cl,</div>
<div class="line">                                       <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a>, data_handles[x][y],</div>
<div class="line">                                       <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[x-1][y],</div>
<div class="line">                                       <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[x+1][y],</div>
<div class="line">                                       <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[x][y-1],</div>
<div class="line">                                       <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[x][y+1],</div>
<div class="line">                                       0);</div>
<div class="line"><a class="code" href="group__API__Codelet__And__Tasks.html#gad0baa8dbfd13e5a7bc3651bcd76022aa">starpu_task_wait_for_all</a>();</div>
</div><!-- fragment --><p>This permits to drop the cost of function call argument passing and parsing.</p>
<p>If the <code>my_distrib</code> function can be inlined by the compiler, the latter can improve the test.</p>
<p>If the <code>size</code> can be made a compile-time constant, the compiler can considerably improve the test further.</p>
<p>If the distribution function is not too complex and the compiler is very good, the latter can even optimize the <code>for</code> loops, thus dramatically reducing the cost of task submission.</p>
<p>A function <a class="el" href="group__API__MPI__Support.html#ga03f635684df3c110aea79ebd59f73165">starpu_mpi_task_build()</a> is also provided with the aim to only construct the task structure. All MPI nodes need to call the function, only the node which is to execute the task will return a valid task structure. Following the execution of the task, all nodes need to call the function <a class="el" href="group__API__MPI__Support.html#ga9c609f3cc579af484808b3e1b8b787d9">starpu_mpi_task_post_build()</a> &ndash; with the same list of arguments as <a class="el" href="group__API__MPI__Support.html#ga03f635684df3c110aea79ebd59f73165">starpu_mpi_task_build()</a> &ndash; to post all the necessary data communications.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> *task;</div>
<div class="line">task = <a class="code" href="group__API__MPI__Support.html#ga03f635684df3c110aea79ebd59f73165">starpu_mpi_task_build</a>(MPI_COMM_WORLD, &amp;cl,</div>
<div class="line">                             <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a>, data_handles[0],</div>
<div class="line">                             <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[1],</div>
<div class="line">                             0);</div>
<div class="line"><span class="keywordflow">if</span> (task) <a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div>
<div class="line"><a class="code" href="group__API__MPI__Support.html#ga9c609f3cc579af484808b3e1b8b787d9">starpu_mpi_task_post_build</a>(MPI_COMM_WORLD, &amp;cl,</div>
<div class="line">                           <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a>, data_handles[0],</div>
<div class="line">                           <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, data_handles[1],</div>
<div class="line">                           0);</div>
</div><!-- fragment --><h1><a class="anchor" id="MPICache"></a>
MPI cache support</h1>
<p>StarPU-MPI automatically optimizes duplicate data transmissions: if an MPI node B needs a piece of data D from MPI node A for several tasks, only one transmission of D will take place from A to B, and the value of D will be kept on B as long as no task modifies D.</p>
<p>If a task modifies D, B will wait for all tasks which need the previous value of D, before invalidating the value of D. As a consequence, it releases the memory occupied by D. Whenever a task running on B needs the new value of D, allocation will take place again to receive it.</p>
<p>Since tasks can be submitted dynamically, StarPU-MPI can not know whether the current value of data D will again be used by a newly-submitted task before being modified by another newly-submitted task, so until a task is submitted to modify the current value, it can not decide by itself whether to flush the cache or not. The application can however explicitly tell StarPU-MPI to flush the cache by calling <a class="el" href="group__API__MPI__Support.html#gacb05635d95f946f099a1772c8bd59c8b">starpu_mpi_cache_flush()</a> or <a class="el" href="group__API__MPI__Support.html#gadf1f289d1cf35bd31df930bc347fb9ce">starpu_mpi_cache_flush_all_data()</a>, for instance in case the data will not be used at all any more (see for instance the cholesky example in mpi/examples/matrix_decomposition), or at least not in the close future. If a newly-submitted task actually needs the value again, another transmission of D will be initiated from A to B. A mere <a class="el" href="group__API__MPI__Support.html#gadf1f289d1cf35bd31df930bc347fb9ce">starpu_mpi_cache_flush_all_data()</a> can for instance be added at the end of the whole algorithm, to express that no data will be reused after that (or at least that it is not interesting to keep them in cache). It may however be interesting to add fine-graph <a class="el" href="group__API__MPI__Support.html#gacb05635d95f946f099a1772c8bd59c8b">starpu_mpi_cache_flush()</a> calls during the algorithm; the effect for the data deallocation will be the same, but it will additionally release some pressure from the StarPU-MPI cache hash table during task submission.</p>
<p>The whole caching behavior can be disabled thanks to the <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_CACHE">STARPU_MPI_CACHE</a> environment variable. The variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_CACHE_STATS">STARPU_MPI_CACHE_STATS</a> can be set to 1 to enable the runtime to display messages when data are added or removed from the cache holding the received data.</p>
<h1><a class="anchor" id="MPIMigration"></a>
MPI Data migration</h1>
<p>The application can dynamically change its mind about the data distribution, to balance the load over MPI nodes for instance. This can be done very simply by requesting an explicit move and then change the registered rank. For instance, we here switch to a new distribution function <code>my_distrib2</code>: we first register any data that wasn't registered already and will be needed, then migrate the data, and register the new location.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; X; x++) {</div>
<div class="line">    <span class="keywordflow">for</span> (y = 0; y &lt; Y; y++) {</div>
<div class="line">        <span class="keywordtype">int</span> mpi_rank = my_distrib2(x, y, size);</div>
<div class="line">        <span class="keywordflow">if</span> (!data_handles[x][y] &amp;&amp; (mpi_rank == my_rank</div>
<div class="line">              || my_rank == my_distrib(x+1, y, size) || my_rank == my_distrib(x-1, y, size)</div>
<div class="line">              || my_rank == my_distrib(x, y+1, size) || my_rank == my_distrib(x, y-1, size)))</div>
<div class="line">            <span class="comment">/* Register newly-needed data */</span></div>
<div class="line">            <a class="code" href="group__API__Data__Interfaces.html#gadcd1aee7fb7226edebe64dfcc46c1d69">starpu_variable_data_register</a>(&amp;data_handles[x][y], -1,</div>
<div class="line">                                          (uintptr_t)NULL, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));</div>
<div class="line">        <span class="keywordflow">if</span> (data_handles[x][y]) {</div>
<div class="line">            <span class="comment">/* Migrate the data */</span></div>
<div class="line">            <a class="code" href="group__API__MPI__Support.html#ga6c581f7133773a98b583e0c51970ecb7">starpu_mpi_get_data_on_node_detached</a>(MPI_COMM_WORLD, data_handles[x][y], mpi_rank, NULL, NULL);</div>
<div class="line">            <span class="comment">/* And register the new rank of the matrix */</span></div>
<div class="line">            <a class="code" href="group__API__MPI__Support.html#ga79ca5db23d267ee7c199864993e434a9">starpu_mpi_data_set_rank</a>(data_handles[x][y], mpi_rank);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>From then on, further tasks submissions will use the new data distribution, which will thus change both MPI communications and task assignments.</p>
<p>Very importantly, since all nodes have to agree on which node owns which data so as to determine MPI communications and task assignments the same way, all nodes have to perform the same data migration, and at the same point among task submissions. It thus does not require a strict synchronization, just a clear separation of task submissions before and after the data redistribution.</p>
<p>Before data unregistration, it has to be migrated back to its original home node (the value, at least), since that is where the user-provided buffer resides. Otherwise the unregistration will complain that it does not have the latest value on the original home node.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; X; x++) {</div>
<div class="line">    <span class="keywordflow">for</span> (y = 0; y &lt; Y; y++) {</div>
<div class="line">        <span class="keywordflow">if</span> (data_handles[x][y]) {</div>
<div class="line">            <span class="keywordtype">int</span> mpi_rank = my_distrib(x, y, size);</div>
<div class="line">            <span class="comment">/* Get back data to original place where the user-provided buffer is.  */</span></div>
<div class="line">            <a class="code" href="group__API__MPI__Support.html#ga6c581f7133773a98b583e0c51970ecb7">starpu_mpi_get_data_on_node_detached</a>(MPI_COMM_WORLD, data_handles[x][y], mpi_rank, NULL, NULL);</div>
<div class="line">            <span class="comment">/* And unregister it */</span></div>
<div class="line">            <a class="code" href="group__API__Data__Management.html#ga586146498466b60d6b81145dfaeb8948">starpu_data_unregister</a>(data_handles[x][y]);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="MPICollective"></a>
MPI Collective Operations</h1>
<p>The functions are described in <a class="el" href="group__API__MPI__Support.html#MPICollectiveOperations">MPI Collective Operations</a>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (rank == root)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Allocate the vector */</span></div>
<div class="line">    vector = malloc(nblocks * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span> *));</div>
<div class="line">    <span class="keywordflow">for</span>(x=0 ; x&lt;nblocks ; x++)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__API__Standard__Memory__Library.html#ga49603eaea3b05e8ced9ba1bd873070c3">starpu_malloc</a>((<span class="keywordtype">void</span> **)&amp;vector[x], block_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Allocate data handles and register data to StarPU */</span></div>
<div class="line">data_handles = malloc(nblocks*<span class="keyword">sizeof</span>(<a class="code" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *));</div>
<div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; nblocks ;  x++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> mpi_rank = my_distrib(x, nodes);</div>
<div class="line">    <span class="keywordflow">if</span> (rank == root) {</div>
<div class="line">        <a class="code" href="group__API__Data__Interfaces.html#ga98ea4083ac39db45b6be75354e66bca1">starpu_vector_data_register</a>(&amp;data_handles[x], <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t)vector[x],</div>
<div class="line">                                    blocks_size, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((mpi_rank == rank) || ((rank == mpi_rank+1 || rank == mpi_rank-1))) {</div>
<div class="line">        <span class="comment">/* I own that index, or i will need it for my computations */</span></div>
<div class="line">        <a class="code" href="group__API__Data__Interfaces.html#ga98ea4083ac39db45b6be75354e66bca1">starpu_vector_data_register</a>(&amp;data_handles[x], -1, (uintptr_t)NULL,</div>
<div class="line">                                   block_size, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">/* I know it&#39;s useless to allocate anything for this */</span></div>
<div class="line">        data_handles[x] = NULL;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (data_handles[x]) {</div>
<div class="line">        <a class="code" href="group__API__MPI__Support.html#gac45e4d77c3d077955bcdc6e1bf0e8cd8">starpu_mpi_data_register</a>(data_handles[x], x*nblocks+y, mpi_rank);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Scatter the matrix among the nodes */</span></div>
<div class="line"><a class="code" href="group__API__MPI__Support.html#ga39ae075749aef08653ade368b9a95ee0">starpu_mpi_scatter_detached</a>(data_handles, nblocks, root, MPI_COMM_WORLD);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Calculation */</span></div>
<div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; nblocks ;  x++) {</div>
<div class="line">    <span class="keywordflow">if</span> (data_handles[x]) {</div>
<div class="line">        <span class="keywordtype">int</span> owner = <a class="code" href="group__API__MPI__Support.html#ga5281ad23b39e64ca254347e89cbb54e2">starpu_data_get_rank</a>(data_handles[x]);</div>
<div class="line">        <span class="keywordflow">if</span> (owner == rank) {</div>
<div class="line">            <a class="code" href="group__API__Insert__Task.html#gad79a50a21fe717126659b2998209c1c6">starpu_task_insert</a>(&amp;cl, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a>, data_handles[x], 0);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Gather the matrix on main node */</span></div>
<div class="line"><a class="code" href="group__API__MPI__Support.html#gaf83405a3154137f00ccf554c5e5684b5">starpu_mpi_gather_detached</a>(data_handles, nblocks, 0, MPI_COMM_WORLD);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 6 2015 21:13:12 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
