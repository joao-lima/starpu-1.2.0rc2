<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>StarPU Handbook: Data Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__API__Data__Management.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a>  </div>
  <div class="headertitle">
<div class="title">Data Management</div>  </div>
</div><!--header-->
<div class="contents">

<p>This section describes the data management facilities provided by StarPU. We show how to use existing data interfaces in <a class="el" href="group__API__Data__Interfaces.html">Data Interfaces</a>, but developers can design their own data interfaces if required.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5f517ab725864d54b0459896a8f8ae07"><td class="memItemLeft" align="right" valign="top">typedef struct _starpu_data_state *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a></td></tr>
<tr class="separator:ga5f517ab725864d54b0459896a8f8ae07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab442391c29c432bdb20e5d70f008f48f"><td class="memItemLeft" align="right" valign="top">typedef struct starpu_arbiter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gab442391c29c432bdb20e5d70f008f48f">starpu_arbiter_t</a></td></tr>
<tr class="separator:gab442391c29c432bdb20e5d70f008f48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1fb3a1ff8622747d653d1b5f41bc41db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a> { <br />
&#160;&#160;<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaacd20c7596d4c1ffc6dbeaa632a6a6a6">STARPU_NONE</a>, 
<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>, 
<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba052ab75035ca297c7955363c605231c8">STARPU_W</a>, 
<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a>, 
<br />
&#160;&#160;<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba2a5d5e11b2ec3aa14f5c9bf94accf6f6">STARPU_SCRATCH</a>, 
<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba6011b5abab92fd996b29d622c4a488f4">STARPU_REDUX</a>, 
<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba64859f7fc1e4f2484dd7f0500f12c30a">STARPU_COMMUTE</a>, 
<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaf96ec45077e70239a826867ed897bd0f">STARPU_SSEND</a>, 
<br />
&#160;&#160;<b>STARPU_ACCESS_MODE_MAX</b>
<br />
 }</td></tr>
<tr class="separator:ga1fb3a1ff8622747d653d1b5f41bc41db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Basic Data Management API</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd670c10eaf5e86fd7553cd469ffcc000"></a>Data management is done at a high-level in StarPU: rather than accessing a mere list of contiguous buffers, the tasks may manipulate data that are described by a high-level construct which we call data interface.</p>
<p>An example of data interface is the "vector" interface which describes a contiguous data array on a spefic memory node. This interface is a simple structure containing the number of elements in the array, the size of the elements, and the address of the array in the appropriate address space (this address may be invalid if there is no valid copy of the array in the memory node). More informations on the data interfaces provided by StarPU are given in <a class="el" href="group__API__Data__Interfaces.html">Data Interfaces</a>.</p>
<p>When a piece of data managed by StarPU is used by a task, the task implementation is given a pointer to an interface describing a valid copy of the data that is accessible from the current processing unit.</p>
<p>Every worker is associated to a memory node which is a logical abstraction of the address space from which the processing unit gets its data. For instance, the memory node associated to the different CPU workers represents main memory (RAM), the memory node associated to a GPU is DRAM embedded on the device. Every memory node is identified by a logical index which is accessible from the function <a class="el" href="group__API__Workers__Properties.html#ga7de6654141ce89ea83c3aba60486396e">starpu_worker_get_memory_node()</a>. When registering a piece of data to StarPU, the specified memory node indicates where the piece of data initially resides (we also call this memory node the home node of a piece of data). </p>
</td></tr>
<tr class="memitem:ga74d62dfa2a733db4bac71caaae751d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga74d62dfa2a733db4bac71caaae751d9d">starpu_data_register</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *handleptr, unsigned home_node, void *data_interface, struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> *ops)</td></tr>
<tr class="separator:ga74d62dfa2a733db4bac71caaae751d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0a0dc4903585e099b2e4b16a22946a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga1d0a0dc4903585e099b2e4b16a22946a">starpu_data_ptr_register</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, unsigned node)</td></tr>
<tr class="separator:ga1d0a0dc4903585e099b2e4b16a22946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be29ee257e3d9c3321df759b8105cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga1be29ee257e3d9c3321df759b8105cb1">starpu_data_register_same</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *handledst, <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handlesrc)</td></tr>
<tr class="separator:ga1be29ee257e3d9c3321df759b8105cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga586146498466b60d6b81145dfaeb8948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga586146498466b60d6b81145dfaeb8948">starpu_data_unregister</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:ga586146498466b60d6b81145dfaeb8948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f95d17759711f7703bf02820e2e49b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gaa1f95d17759711f7703bf02820e2e49b">starpu_data_unregister_no_coherency</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:gaa1f95d17759711f7703bf02820e2e49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa34753bff1d29c20f0a0e361020b4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga4fa34753bff1d29c20f0a0e361020b4e">starpu_data_unregister_submit</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:ga4fa34753bff1d29c20f0a0e361020b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e82fe020ec010bcacb6aee16021607c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga4e82fe020ec010bcacb6aee16021607c">starpu_data_invalidate</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:ga4e82fe020ec010bcacb6aee16021607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b01fdf769f8f2eb222ecde42afbc81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga06b01fdf769f8f2eb222ecde42afbc81">starpu_data_invalidate_submit</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:ga06b01fdf769f8f2eb222ecde42afbc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53e7b21c7426c9845a1046cfe5becce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gae53e7b21c7426c9845a1046cfe5becce">starpu_data_set_wt_mask</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, uint32_t wt_mask)</td></tr>
<tr class="separator:gae53e7b21c7426c9845a1046cfe5becce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce32e79b2f07fb474b6ae10006abb1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga9ce32e79b2f07fb474b6ae10006abb1f">starpu_data_fetch_on_node</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, unsigned node, unsigned async)</td></tr>
<tr class="separator:ga9ce32e79b2f07fb474b6ae10006abb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57687b811ced00dbfc35af73164a72aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga57687b811ced00dbfc35af73164a72aa">starpu_data_prefetch_on_node</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, unsigned node, unsigned async)</td></tr>
<tr class="separator:ga57687b811ced00dbfc35af73164a72aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a24f94d0aa2bbfab8957c3dd13949a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gad5a24f94d0aa2bbfab8957c3dd13949a">starpu_data_idle_prefetch_on_node</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, unsigned node, unsigned async)</td></tr>
<tr class="separator:gad5a24f94d0aa2bbfab8957c3dd13949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4b4f7f9f0a26f65a1e149525a09bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gafd4b4f7f9f0a26f65a1e149525a09bfd">starpu_data_wont_use</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:gafd4b4f7f9f0a26f65a1e149525a09bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75907283eef0a058a040ff06de87b4b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga75907283eef0a058a040ff06de87b4b2">starpu_data_lookup</a> (const void *ptr)</td></tr>
<tr class="separator:ga75907283eef0a058a040ff06de87b4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac561fd637be17b74f0456106dc25f5d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gac561fd637be17b74f0456106dc25f5d1">starpu_data_request_allocation</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, unsigned node)</td></tr>
<tr class="separator:gac561fd637be17b74f0456106dc25f5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a6122bae224d714383ae775434cdce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga9a6122bae224d714383ae775434cdce3">starpu_data_query_status</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, int memory_node, int *is_allocated, int *is_valid, int *is_requested)</td></tr>
<tr class="separator:ga9a6122bae224d714383ae775434cdce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc8031c1b437d35232cd1700d83d472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gaedc8031c1b437d35232cd1700d83d472">starpu_data_advise_as_important</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, unsigned is_important)</td></tr>
<tr class="separator:gaedc8031c1b437d35232cd1700d83d472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5ba1c1cfefc1f81a4095cf3c213e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga1f5ba1c1cfefc1f81a4095cf3c213e54">starpu_data_set_reduction_methods</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, struct <a class="el" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> *redux_cl, struct <a class="el" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> *init_cl)</td></tr>
<tr class="separator:ga1f5ba1c1cfefc1f81a4095cf3c213e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d64eee72db978a53bf3e5081766d1b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gac0d64eee72db978a53bf3e5081766d1b">starpu_data_get_interface_ops</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:gac0d64eee72db978a53bf3e5081766d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Access registered data from the application</h2></td></tr>
<tr class="memitem:ga2b9b64ac9a650d8c8942b4227e6fce75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga2b9b64ac9a650d8c8942b4227e6fce75">STARPU_DATA_ACQUIRE_CB</a>(handle,  mode,  code)</td></tr>
<tr class="separator:ga2b9b64ac9a650d8c8942b4227e6fce75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6eb535cf9bf46a7ef9ad2d845c675a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a> mode)</td></tr>
<tr class="separator:gae6eb535cf9bf46a7ef9ad2d845c675a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358aba7459b7f99a6dbaa189ce57b925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga358aba7459b7f99a6dbaa189ce57b925">starpu_data_acquire_cb</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a> mode, void(*callback)(void *), void *arg)</td></tr>
<tr class="separator:ga358aba7459b7f99a6dbaa189ce57b925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70ee8a92cbb3935ec3ca0d40f443f860"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga70ee8a92cbb3935ec3ca0d40f443f860">starpu_data_acquire_cb_sequential_consistency</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a> mode, void(*callback)(void *), void *arg, int sequential_consistency)</td></tr>
<tr class="separator:ga70ee8a92cbb3935ec3ca0d40f443f860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b2ca6406b5839062346200123551638"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga3b2ca6406b5839062346200123551638">starpu_data_acquire_on_node</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, int node, enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a> mode)</td></tr>
<tr class="separator:ga3b2ca6406b5839062346200123551638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db878885ebbee4729d8aed6a0479262"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga8db878885ebbee4729d8aed6a0479262">starpu_data_acquire_on_node_cb</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, int node, enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a> mode, void(*callback)(void *), void *arg)</td></tr>
<tr class="separator:ga8db878885ebbee4729d8aed6a0479262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd48044a523ed5a4e11598596096dc52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gafd48044a523ed5a4e11598596096dc52">starpu_data_acquire_on_node_cb_sequential_consistency</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, int node, enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a> mode, void(*callback)(void *), void *arg, int sequential_consistency)</td></tr>
<tr class="separator:gafd48044a523ed5a4e11598596096dc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc145017bafa2948109c624715de77a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:gadc145017bafa2948109c624715de77a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b95764e9545fc367cb995950e82f449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga5b95764e9545fc367cb995950e82f449">starpu_data_release_on_node</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, int node)</td></tr>
<tr class="separator:ga5b95764e9545fc367cb995950e82f449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53fde892288fe6356d2f15c024ce89df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#gab442391c29c432bdb20e5d70f008f48f">starpu_arbiter_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga53fde892288fe6356d2f15c024ce89df">starpu_arbiter_create</a> (void)</td></tr>
<tr class="separator:ga53fde892288fe6356d2f15c024ce89df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cbc51da2f2b7025c534d6862866bf81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#ga9cbc51da2f2b7025c534d6862866bf81">starpu_data_assign_arbiter</a> (<a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> handle, <a class="el" href="group__API__Data__Management.html#gab442391c29c432bdb20e5d70f008f48f">starpu_arbiter_t</a> arbiter)</td></tr>
<tr class="separator:ga9cbc51da2f2b7025c534d6862866bf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca578e24cc2834938154b4ab973d35c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Management.html#gaca578e24cc2834938154b4ab973d35c6">starpu_arbiter_destroy</a> (<a class="el" href="group__API__Data__Management.html#gab442391c29c432bdb20e5d70f008f48f">starpu_arbiter_t</a>)</td></tr>
<tr class="separator:gaca578e24cc2834938154b4ab973d35c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This section describes the data management facilities provided by StarPU. We show how to use existing data interfaces in <a class="el" href="group__API__Data__Interfaces.html">Data Interfaces</a>, but developers can design their own data interfaces if required. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga2b9b64ac9a650d8c8942b4227e6fce75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STARPU_DATA_ACQUIRE_CB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">code&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__API__Data__Management.html#ga2b9b64ac9a650d8c8942b4227e6fce75">STARPU_DATA_ACQUIRE_CB()</a> is the same as <a class="el" href="group__API__Data__Management.html#ga358aba7459b7f99a6dbaa189ce57b925">starpu_data_acquire_cb()</a>, except that the code to be executed in a callback is directly provided as a macro parameter, and the data <code>handle</code> is automatically released after it. This permits to easily execute code which depends on the value of some registered data. This is non-blocking too and may be called from task callbacks. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5f517ab725864d54b0459896a8f8ae07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>StarPU uses <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> as an opaque handle to manage a piece of data. Once a piece of data has been registered to StarPU, it is associated to a <a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> which keeps track of the state of the piece of data over the entire machine, so that we can maintain data consistency and locate data replicates for instance. </p>

</div>
</div>
<a class="anchor" id="gab442391c29c432bdb20e5d70f008f48f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#gab442391c29c432bdb20e5d70f008f48f">starpu_arbiter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an arbiter, which implements an advanced but centralized management of concurrent data accesses, see <a class="el" href="DataManagement.html#ConcurrentDataAccess">Concurrent Data accesses</a> for the details. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga1fb3a1ff8622747d653d1b5f41bc41db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This datatype describes a data access mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1fb3a1ff8622747d653d1b5f41bc41dbaacd20c7596d4c1ffc6dbeaa632a6a6a6"></a>STARPU_NONE&#160;</td><td class="fielddoc">
<p>TODO </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5"></a>STARPU_R&#160;</td><td class="fielddoc">
<p>read-only mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb3a1ff8622747d653d1b5f41bc41dba052ab75035ca297c7955363c605231c8"></a>STARPU_W&#160;</td><td class="fielddoc">
<p>write-only mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e"></a>STARPU_RW&#160;</td><td class="fielddoc">
<p>read-write mode. This is equivalent to <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a>|<a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba052ab75035ca297c7955363c605231c8">STARPU_W</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb3a1ff8622747d653d1b5f41bc41dba2a5d5e11b2ec3aa14f5c9bf94accf6f6"></a>STARPU_SCRATCH&#160;</td><td class="fielddoc">
<p>A temporary buffer is allocated for the task, but StarPU does not enforce data consistency&mdash;i.e. each device has its own buffer, independently from each other (even for CPUs), and no data transfer is ever performed. This is useful for temporary variables to avoid allocating/freeing buffers inside each task. Currently, no behavior is defined concerning the relation with the <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaa4c2445a344c592fb7b1adfcf1d2e1f5">STARPU_R</a> and <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba052ab75035ca297c7955363c605231c8">STARPU_W</a> modes and the value provided at registration &mdash; i.e., the value of the scratch buffer is undefined at entry of the codelet function. It is being considered for future extensions at least to define the initial value. For now, data to be used in <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba2a5d5e11b2ec3aa14f5c9bf94accf6f6">STARPU_SCRATCH</a> mode should be registered with node <code>-1</code> and a <code>NULL</code> pointer, since the value of the provided buffer is simply ignored for now. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb3a1ff8622747d653d1b5f41bc41dba6011b5abab92fd996b29d622c4a488f4"></a>STARPU_REDUX&#160;</td><td class="fielddoc">
<p>todo </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb3a1ff8622747d653d1b5f41bc41dba64859f7fc1e4f2484dd7f0500f12c30a"></a>STARPU_COMMUTE&#160;</td><td class="fielddoc">
<p>In addition to that, <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba64859f7fc1e4f2484dd7f0500f12c30a">STARPU_COMMUTE</a> can be passed along <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba052ab75035ca297c7955363c605231c8">STARPU_W</a> or <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba20da2e02cd303015b5967dbf72ef3e1e">STARPU_RW</a> to express that StarPU can let tasks commute, which is useful e.g. when bringing a contribution into some data, which can be done in any order (but still require sequential consistency against reads or non-commutative writes). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1fb3a1ff8622747d653d1b5f41bc41dbaf96ec45077e70239a826867ed897bd0f"></a>STARPU_SSEND&#160;</td><td class="fielddoc">
<p>used in <a class="el" href="group__API__MPI__Support.html#ga04229edbc905be8eefce8fb58bfccf8f">starpu_mpi_insert_task()</a> to specify the data has to be sent using a synchronous and non-blocking mode (see <a class="el" href="group__API__MPI__Support.html#ga8374cb42eb85e86e58ccfa8e0c5e8aab">starpu_mpi_issend()</a>) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga74d62dfa2a733db4bac71caaae751d9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handleptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>home_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a piece of data into the handle located at the <code>handleptr</code> address. The <code>data_interface</code> buffer contains the initial description of the data in the <code>home_node</code>. The <code>ops</code> argument is a pointer to a structure describing the different methods used to manipulate this type of interface. See <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> for more details on this structure. If <code>home_node</code> is -1, StarPU will automatically allocate the memory when it is used for the first time in write-only mode. Once such data handle has been automatically allocated, it is possible to access it using any access mode. Note that StarPU supplies a set of predefined types of interface (e.g. vector or matrix) which can be registered by the means of helper functions (e.g. <a class="el" href="group__API__Data__Interfaces.html#ga98ea4083ac39db45b6be75354e66bca1">starpu_vector_data_register()</a> or <a class="el" href="group__API__Data__Interfaces.html#ga7af287b9089acc7cf4b3b7ed19d82abb">starpu_matrix_data_register()</a>). </p>

</div>
</div>
<a class="anchor" id="ga1d0a0dc4903585e099b2e4b16a22946a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_ptr_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register that a buffer for <code>handle</code> on <code>node</code> will be set. This is typically used by starpu_*_ptr_register helpers before setting the interface pointers for this node, to tell the core that that is now allocated. </p>

</div>
</div>
<a class="anchor" id="ga1be29ee257e3d9c3321df759b8105cb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_register_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handledst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handlesrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a new piece of data into the handle <code>handledst</code> with the same interface as the handle <code>handlesrc</code>. </p>

</div>
</div>
<a class="anchor" id="ga586146498466b60d6b81145dfaeb8948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function unregisters a data handle from StarPU. If the data was automatically allocated by StarPU because the home node was -1, all automatically allocated buffers are freed. Otherwise, a valid copy of the data is put back into the home node in the buffer that was initially registered. Using a data handle that has been unregistered from StarPU results in an undefined behaviour. In case we do not need to update the value of the data in the home node, we can use the function <a class="el" href="group__API__Data__Management.html#gaa1f95d17759711f7703bf02820e2e49b">starpu_data_unregister_no_coherency()</a> instead. </p>

</div>
</div>
<a class="anchor" id="gaa1f95d17759711f7703bf02820e2e49b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unregister_no_coherency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the same as <a class="el" href="group__API__Data__Management.html#ga586146498466b60d6b81145dfaeb8948">starpu_data_unregister()</a>, except that StarPU does not put back a valid copy into the home node, in the buffer that was initially registered. </p>

</div>
</div>
<a class="anchor" id="ga4fa34753bff1d29c20f0a0e361020b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unregister_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the data handle once it is not needed anymore by any submitted task. No coherency is assumed. </p>

</div>
</div>
<a class="anchor" id="ga4e82fe020ec010bcacb6aee16021607c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy all replicates of the data handle immediately. After data invalidation, the first access to the handle must be performed in write-only mode. Accessing an invalidated data in read-mode results in undefined behaviour. </p>

</div>
</div>
<a class="anchor" id="ga06b01fdf769f8f2eb222ecde42afbc81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_invalidate_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Submits invalidation of the data handle after completion of previously submitted tasks. </p>

</div>
</div>
<a class="anchor" id="gae53e7b21c7426c9845a1046cfe5becce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_set_wt_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wt_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the write-through mask of a given data (and its children), i.e. a bitmask of nodes where the data should be always replicated after modification. It also prevents the data from being evicted from these nodes when memory gets scarse. When the data is modified, it is automatically transfered into those memory node. For instance a <code>1&lt;&lt;0</code> write-through mask means that the CUDA workers will commit their changes in main memory (node 0). </p>

</div>
</div>
<a class="anchor" id="ga9ce32e79b2f07fb474b6ae10006abb1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_fetch_on_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue a fetch request for a given data to a given node, i.e. requests that the data be replicated to the given node as soon as possible, so that it is available there for tasks. If the <code>async</code> parameter is 0, the call will block until the transfer is achieved, else the call will return immediately, after having just queued the request. In the latter case, the request will asynchronously wait for the completion of any task writing on the data. </p>

</div>
</div>
<a class="anchor" id="ga57687b811ced00dbfc35af73164a72aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_prefetch_on_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue a prefetch request for a given data to a given node, i.e. requests that the data be replicated to the given node when there is room for it, so that it is available there for tasks. If the <code>async</code> parameter is 0, the call will block until the transfer is achieved, else the call will return immediately, after having just queued the request. In the latter case, the request will asynchronously wait for the completion of any task writing on the data. </p>

</div>
</div>
<a class="anchor" id="gad5a24f94d0aa2bbfab8957c3dd13949a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_idle_prefetch_on_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue an idle prefetch request for a given data to a given node, i.e. requests that the data be replicated to the given node, so that it is available there for tasks, but only when the bus is really idle. If the <code>async</code> parameter is 0, the call will block until the transfer is achieved, else the call will return immediately, after having just queued the request. In the latter case, the request will asynchronously wait for the completion of any task writing on the data. </p>

</div>
</div>
<a class="anchor" id="gafd4b4f7f9f0a26f65a1e149525a09bfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_wont_use </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advise StarPU that this handle will not be used in the close future, and is thus a good candidate for eviction from GPUs. StarPU will thus write its value back to its home node when the bus is idle, and select this data in priority for eviction when memory gets low. </p>

</div>
</div>
<a class="anchor" id="ga75907283eef0a058a040ff06de87b4b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a> starpu_data_lookup </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the handle corresponding to the data pointed to by the <code>ptr</code> host pointer. </p>

</div>
</div>
<a class="anchor" id="gac561fd637be17b74f0456106dc25f5d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_request_allocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly ask StarPU to allocate room for a piece of data on the specified memory node. </p>

</div>
</div>
<a class="anchor" id="ga9a6122bae224d714383ae775434cdce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_query_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memory_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>is_allocated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>is_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>is_requested</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the status of <code>handle</code> on the specified <code>memory_node</code>. </p>

</div>
</div>
<a class="anchor" id="gaedc8031c1b437d35232cd1700d83d472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_advise_as_important </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>is_important</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allows to specify that a piece of data can be discarded without impacting the application. </p>

</div>
</div>
<a class="anchor" id="ga1f5ba1c1cfefc1f81a4095cf3c213e54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_set_reduction_methods </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> *&#160;</td>
          <td class="paramname"><em>redux_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> *&#160;</td>
          <td class="paramname"><em>init_cl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This sets the codelets to be used for <code>handle</code> when it is accessed in the mode <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba6011b5abab92fd996b29d622c4a488f4">STARPU_REDUX</a>. Per-worker buffers will be initialized with the codelet <code>init_cl</code>, and reduction between per-worker buffers will be done with the codelet <code>redux_cl</code>. </p>

</div>
</div>
<a class="anchor" id="gac0d64eee72db978a53bf3e5081766d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> * starpu_data_get_interface_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>todo </p>

</div>
</div>
<a class="anchor" id="gae6eb535cf9bf46a7ef9ad2d845c675a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The application must call this function prior to accessing registered data from main memory outside tasks. StarPU ensures that the application will get an up-to-date copy of the data in main memory located where the data was originally registered, and that all concurrent accesses (e.g. from tasks) will be consistent with the access mode specified in the mode argument. <a class="el" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release()</a> must be called once the application does not need to access the piece of data anymore. Note that implicit data dependencies are also enforced by <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a>, i.e. <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a> will wait for all tasks scheduled to work on the data, unless they have been disabled explictly by calling <a class="el" href="group__API__Implicit__Data__Dependencies.html#ga26f17239b14354e61eef0710ffadc434">starpu_data_set_default_sequential_consistency_flag()</a> or <a class="el" href="group__API__Implicit__Data__Dependencies.html#ga273df19e4cad1c05ec5df697bcec4444">starpu_data_set_sequential_consistency_flag()</a>. <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a> is a blocking call, so that it cannot be called from tasks or from their callbacks (in that case, <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a> returns <code>-EDEADLK</code>). Upon successful completion, this function returns 0. </p>

</div>
</div>
<a class="anchor" id="ga358aba7459b7f99a6dbaa189ce57b925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_acquire_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronous equivalent of <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a>. When the data specified in <code>handle</code> is available in the appropriate access mode, the <code>callback</code> function is executed. The application may access the requested data during the execution of this <code>callback</code>. The <code>callback</code> function must call <a class="el" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release()</a> once the application does not need to access the piece of data anymore. Note that implicit data dependencies are also enforced by <a class="el" href="group__API__Data__Management.html#ga358aba7459b7f99a6dbaa189ce57b925">starpu_data_acquire_cb()</a> in case they are not disabled. Contrary to <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a>, this function is non-blocking and may be called from task callbacks. Upon successful completion, this function returns 0. </p>

</div>
</div>
<a class="anchor" id="ga70ee8a92cbb3935ec3ca0d40f443f860"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_acquire_cb_sequential_consistency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequential_consistency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent of <a class="el" href="group__API__Data__Management.html#ga358aba7459b7f99a6dbaa189ce57b925">starpu_data_acquire_cb()</a> with the possibility of enabling or disabling data dependencies. When the data specified in <code>handle</code> is available in the appropriate access mode, the <code>callback</code> function is executed. The application may access the requested data during the execution of this <code>callback</code>. The <code>callback</code> function must call <a class="el" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release()</a> once the application does not need to access the piece of data anymore. Note that implicit data dependencies are also enforced by <a class="el" href="group__API__Data__Management.html#ga70ee8a92cbb3935ec3ca0d40f443f860">starpu_data_acquire_cb_sequential_consistency()</a> in case they are not disabled specifically for the given <code>handle</code> or by the parameter <code>sequential_consistency</code>. Similarly to <a class="el" href="group__API__Data__Management.html#ga358aba7459b7f99a6dbaa189ce57b925">starpu_data_acquire_cb()</a>, this function is non-blocking and may be called from task callbacks. Upon successful completion, this function returns 0. </p>

</div>
</div>
<a class="anchor" id="ga3b2ca6406b5839062346200123551638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_acquire_on_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the same as <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a>, except that the data will be available on the given memory node instead of main memory. </p>

</div>
</div>
<a class="anchor" id="ga8db878885ebbee4729d8aed6a0479262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_acquire_on_node_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the same as <a class="el" href="group__API__Data__Management.html#ga358aba7459b7f99a6dbaa189ce57b925">starpu_data_acquire_cb()</a>, except that the data will be available on the given memory node instead of main memory. </p>

</div>
</div>
<a class="anchor" id="gafd48044a523ed5a4e11598596096dc52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_acquire_on_node_cb_sequential_consistency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__API__Data__Management.html#ga1fb3a1ff8622747d653d1b5f41bc41db">starpu_data_access_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequential_consistency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the same as <a class="el" href="group__API__Data__Management.html#ga70ee8a92cbb3935ec3ca0d40f443f860">starpu_data_acquire_cb_sequential_consistency()</a>, except that the data will be available on the given memory node instead of main memory. </p>

</div>
</div>
<a class="anchor" id="gadc145017bafa2948109c624715de77a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function releases the piece of data acquired by the application either by <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a> or by <a class="el" href="group__API__Data__Management.html#ga358aba7459b7f99a6dbaa189ce57b925">starpu_data_acquire_cb()</a>. </p>

</div>
</div>
<a class="anchor" id="ga5b95764e9545fc367cb995950e82f449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_release_on_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the same as <a class="el" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release()</a>, except that the data will be available on the given memory <code>node</code> instead of main memory. </p>

</div>
</div>
<a class="anchor" id="ga53fde892288fe6356d2f15c024ce89df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#gab442391c29c432bdb20e5d70f008f48f">starpu_arbiter_t</a> starpu_arbiter_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This creates a data access arbiter, see <a class="el" href="DataManagement.html#ConcurrentDataAccess">Concurrent Data accesses</a> for the details </p>

</div>
</div>
<a class="anchor" id="ga9cbc51da2f2b7025c534d6862866bf81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_assign_arbiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#ga5f517ab725864d54b0459896a8f8ae07">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gab442391c29c432bdb20e5d70f008f48f">starpu_arbiter_t</a>&#160;</td>
          <td class="paramname"><em>arbiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This makes accesses to <code>handle</code> managed by <code>arbiter</code> </p>

</div>
</div>
<a class="anchor" id="gaca578e24cc2834938154b4ab973d35c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_arbiter_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gab442391c29c432bdb20e5d70f008f48f">starpu_arbiter_t</a>&#160;</td>
          <td class="paramname"><em>arbiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This destroys the <code>arbiter</code> . This must only be called after all data assigned to it have been unregistered. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 6 2015 21:13:12 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
